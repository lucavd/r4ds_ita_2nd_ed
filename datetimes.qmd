# Dates and times {#sec-dates-and-times}

```{r}
#| echo: false
source("_common.R")

# https://github.com/tidyverse/lubridate/issues/1058
options(warnPartialMatchArgs = FALSE)
```

## Introduzione

Questo capitolo ti mostrerà come lavorare con date e orari in R.
A prima vista, date e orari sembrano semplici.
Li usi tutto il tempo nella tua vita normale, e non sembrano causare molta confusione.
Tuttavia, più impari su date e orari, più complicati sembrano diventare!

Per scaldarci pensa a quanti giorni ci sono in un anno, e quante ore ci sono in un giorno.
Probabilmente hai ricordato che la maggior parte degli anni ha 365 giorni, ma gli anni bisestili ne hanno 366.
Conosci la regola completa per determinare se un anno è bisestile[^datetimes-1]?
Il numero di ore in un giorno è un po' meno ovvio: la maggior parte dei giorni ha 24 ore, ma in luoghi che usano l'ora legale (DST), un giorno all'anno ha 23 ore e un altro ne ha 25.

[^datetimes-1]: Un anno è bisestile se è divisibile per 4, a meno che non sia anche divisibile per 100, eccetto se è anche divisibile per 400.
    In altre parole, in ogni insieme di 400 anni, ci sono 97 anni bisestili.

Date e orari sono difficili perché devono riconciliare due fenomeni fisici (la rotazione della Terra e la sua orbita attorno al sole) con una serie di fenomeni geopolitici inclusi mesi, fusi orari e ora legale.
Questo capitolo non ti insegnerà ogni singolo dettaglio su date e orari, ma ti darà una solida base di competenze pratiche che ti aiuteranno con le sfide comuni dell'analisi dei dati.

Iniziamo mostrandoti come creare date-time da vari input, e poi una volta che hai una date-time, come puoi estrarre componenti come anno, mese e giorno.
Poi ci immergeremo nell'argomento difficile del lavorare con gli intervalli di tempo, che vengono in una varietà di forme a seconda di cosa stai cercando di fare.
Concluderemo con una breve discussione delle sfide aggiuntive poste dai fusi orari.

### Prerequisiti

Questo capitolo si concentrerà sul package **lubridate**, che rende più facile lavorare con date e orari in R.
Dalla release più recente del tidyverse, lubridate fa parte del core tidyverse.
Avremo anche bisogno di nycflights13 per dati di pratica.

```{r}
#| message: false
library(tidyverse)
library(nycflights13)
```

## Creare date/time {#sec-creating-datetimes}

Ci sono tre tipi di dati date/time che si riferiscono a un istante nel tempo:

-   Una **data**.
    I tibble la stampano come `<date>`.

-   Un **orario** all'interno di un giorno.
    I tibble lo stampano come `<time>`.

-   Una **data-time** è una data più un orario: identifica univocamente un istante nel tempo (tipicamente al secondo più vicino).
    I tibble la stampano come `<dttm>`.
    R base le chiama POSIXct, ma non è esattamente facile da pronunciare.

In questo capitolo ci concentreremo su date e date-time dato che R non ha una classe nativa per memorizzare gli orari.
Se ne hai bisogno di una, puoi usare il package **hms**.

Dovresti sempre usare il tipo di dato più semplice possibile che funzioni per le tue esigenze.
Questo significa che se puoi usare una data invece di una date-time, dovresti farlo.
Le date-time sono sostanzialmente più complicate a causa della necessità di gestire i fusi orari, sui quali torneremo alla fine del capitolo.

Per ottenere la data o date-time corrente puoi usare `today()` o `now()`:

```{r}
today()
now()
```

Altrimenti, le sezioni seguenti descrivono i quattro modi in cui probabilmente creerai una date/time:

-   Durante la lettura di un file con readr.
-   Da una stringa.
-   Da componenti date-time individuali.
-   Da un oggetto date/time esistente.

### Durante l'importazione

Se il tuo CSV contiene una data o date-time ISO8601, non devi fare nulla; readr la riconoscerà automaticamente:

```{r}
#| message: false
csv <- "
  date,datetime
  2022-01-02,2022-01-02 05:12
"
read_csv(csv)
```

Se non hai mai sentito parlare di **ISO8601** prima, è uno standard internazionale[^datetimes-2] per scrivere date dove i componenti di una data sono organizzati dal più grande al più piccolo separati da `-`. Ad esempio, in ISO8601 il 3 maggio 2022 è `2022-05-03`. Le date ISO8601 possono anche includere orari, dove ora, minuto e secondo sono separati da `:`, e i componenti data e orario sono separati da una `T` o da uno spazio.
Ad esempio, potresti scrivere le 4:26pm del 3 maggio 2022 come `2022-05-03 16:26` o `2022-05-03T16:26`.

[^datetimes-2]: <https://xkcd.com/1179/>

Per altri formati date-time, dovrai usare `col_types` più `col_date()` o `col_datetime()` insieme a un formato date-time.
Il formato date-time usato da readr è uno standard usato in molti linguaggi di programmazione, descrivendo un componente data con un `%` seguito da un singolo carattere.
Ad esempio, `%Y-%m-%d` specifica una data che è un anno, `-`, mese (come numero) `-`, giorno.
La Tabella @tbl-date-formats elenca tutte le opzioni.

| Type  | Code  | Meaning                        | Example         |
|-------|-------|--------------------------------|-----------------|
| Year  | `%Y`  | 4 digit year                   | 2021            |
|       | `%y`  | 2 digit year                   | 21              |
| Month | `%m`  | Number                         | 2               |
|       | `%b`  | Abbreviated name               | Feb             |
|       | `%B`  | Full name                      | February        |
| Day   | `%d`  | One or two digits              | 2               |
|       | `%e`  | Two digits                     | 02              |
| Time  | `%H`  | 24-hour hour                   | 13              |
|       | `%I`  | 12-hour hour                   | 1               |
|       | `%p`  | AM/PM                          | pm              |
|       | `%M`  | Minutes                        | 35              |
|       | `%S`  | Seconds                        | 45              |
|       | `%OS` | Seconds with decimal component | 45.35           |
|       | `%Z`  | Time zone name                 | America/Chicago |
|       | `%z`  | Offset from UTC                | +0800           |
| Other | `%.`  | Skip one non-digit             | :               |
|       | `%*`  | Skip any number of non-digits  |                 |

: Tutti i formati data compresi da readr {#tbl-date-formats}

E questo codice mostra alcune opzioni applicate a una data molto ambigua:

```{r}
#| messages: false
csv <- "
  date
  01/02/15
"

read_csv(csv, col_types = cols(date = col_date("%m/%d/%y")))

read_csv(csv, col_types = cols(date = col_date("%d/%m/%y")))

read_csv(csv, col_types = cols(date = col_date("%y/%m/%d")))
```

Nota che non importa come specifichi il formato data, è sempre visualizzato nello stesso modo una volta che lo ottieni in R.

Se stai usando `%b` o `%B` e lavorando con date non inglesi, dovrai anche fornire un `locale()`.
Vedi la lista delle lingue integrate in `date_names_langs()`, o crea la tua con `date_names()`,

### Da stringhe

Il linguaggio di specifica date-time è potente, ma richiede un'analisi attenta del formato data.
Un approccio alternativo è usare gli helper di lubridate che tentano di determinare automaticamente il formato una volta che specifichi l'ordine del componente.
Per usarli, identifica l'ordine in cui anno, mese e giorno appaiono nelle tue date, poi disponi "y", "m", e "d" nello stesso ordine.
Questo ti dà il nome della funzione lubridate che parserà la tua data.
Ad esempio:

```{r}
ymd("2017-01-31")
mdy("January 31st, 2017")
dmy("31-Jan-2017")
```

`ymd()` e amici creano date.
Per creare una date-time, aggiungi un underscore e uno o più di "h", "m", e "s" al nome della funzione di parsing:

```{r}
ymd_hms("2017-01-31 20:11:59")
mdy_hm("01/31/2017 08:01")
```

Puoi anche forzare la creazione di una date-time da una data fornendo un fuso orario:

```{r}
ymd("2017-01-31", tz = "UTC")
```

Qui uso il fuso orario UTC[^datetimes-3] che potresti anche conoscere come GMT, o Greenwich Mean Time, l'ora a 0° di longitudine[^datetimes-4]
. Non usa l'ora legale, rendendolo un po' più facile con cui calcolare
.

[^datetimes-3]: Potresti chiederti cosa significhi UTC.
    È un compromesso tra l'inglese "Coordinated Universal Time" e il francese "Temps Universel Coordonné".

[^datetimes-4]: Nessun premio per indovinare quale paese ha inventato il sistema di longitudine.

### Da componenti individuali

Invece di una singola stringa, a volte avrai i componenti individuali della date-time distribuiti su più colonne.
Questo è quello che abbiamo nei dati `flights`:

```{r}
flights |> 
  select(year, month, day, hour, minute)
```

Per creare una date/time da questo tipo di input, usa `make_date()` per le date, o `make_datetime()` per le date-time:

```{r}
flights |> 
  select(year, month, day, hour, minute) |> 
  mutate(departure = make_datetime(year, month, day, hour, minute))
```

Facciamo la stessa cosa per ognuna delle quattro colonne temporali in `flights`.
I tempi sono rappresentati in un formato leggermente strano, quindi usiamo l'aritmetica modulo per estrarre i componenti ora e minuto.
Una volta che abbiamo creato le variabili date-time, ci concentriamo sulle variabili che esploreremo nel resto del capitolo.

```{r}
make_datetime_100 <- function(year, month, day, time) {
  make_datetime(year, month, day, time %/% 100, time %% 100)
}

flights_dt <- flights |> 
  filter(!is.na(dep_time), !is.na(arr_time)) |> 
  mutate(
    dep_time = make_datetime_100(year, month, day, dep_time),
    arr_time = make_datetime_100(year, month, day, arr_time),
    sched_dep_time = make_datetime_100(year, month, day, sched_dep_time),
    sched_arr_time = make_datetime_100(year, month, day, sched_arr_time)
  ) |> 
  select(origin, dest, ends_with("delay"), ends_with("time"))

flights_dt
```

Con questi dati, possiamo visualizzare la distribuzione degli orari di partenza durante l'anno:

```{r}
#| fig.alt: >
#|   A frequency polyon with departure time (Jan-Dec 2013) on the x-axis
#|   and number of flights on the y-axis (0-1000). The frequency polygon
#|   is binned by day so you see a time series of flights by day. The
#|   pattern is dominated by a weekly pattern; there are fewer flights 
#|   on weekends. The are few days that stand out as having a surprisingly
#|   few flights in early February, early July, late November, and late
#|   December.
flights_dt |> 
  ggplot(aes(x = dep_time)) + 
  geom_freqpoly(binwidth = 86400) # 86400 secondi = 1 giorno
```

O all'interno di un singolo giorno:

```{r}
#| fig.alt: >
#|   A frequency polygon with departure time (6am - midnight Jan 1) on the
#|   x-axis, number of flights on the y-axis (0-17), binned into 10 minute
#|   increments. It's hard to see much pattern because of high variability,
#|   but most bins have 8-12 flights, and there are markedly fewer flights 
#|   before 6am and after 8pm.
flights_dt |> 
  filter(dep_time < ymd(20130102)) |> 
  ggplot(aes(x = dep_time)) + 
  geom_freqpoly(binwidth = 600) # 600 s = 10 minuti
```

Nota che quando usi date-time in un contesto numerico (come in un istogramma), 1 significa 1 secondo, quindi una binwidth di 86400 significa un giorno.
Per le date, 1 significa 1 giorno.

### Da altri tipi

Potresti voler passare tra una date-time e una data.
Questo è il compito di `as_datetime()` e `as_date()`:

```{r}
as_datetime(today())
as_date(now())
```

A volte otterrai date/time come offset numerici dall'"Unix Epoch", 1970-01-01.
Se l'offset è in secondi, usa `as_datetime()`; se è in giorni, usa `as_date()`.

```{r}
as_datetime(60 * 60 * 10)
as_date(365 * 10 + 2)
```

### Esercizi

1.  Cosa succede se fai il parsing di una stringa che contiene date non valide?

    ```{r}
    #| eval: false

    ymd(c("2010-10-10", "bananas"))
    ```

2.  Cosa fa l'argomento `tzone` di `today()`?
    Perché è importante?

3.  Per ognuna delle seguenti date-time, mostra come faresti il parsing usando una specifica di colonna readr e una funzione lubridate.

    ```{r}
    d1 <- "January 1, 2010"
    d2 <- "2015-Mar-07"
    d3 <- "06-Jun-2017"
    d4 <- c("August 19 (2015)", "July 1 (2015)")
    d5 <- "12/30/14" # 30 dic, 2014
    t1 <- "1705"
    t2 <- "11:15:10.12 PM"
    ```

## Componenti date-time

Ora che sai come ottenere dati date-time nelle strutture dati date-time di R, esploriamo cosa puoi farci.
Questa sezione si concentrerà sulle funzioni accessor che ti permettono di ottenere e impostare componenti individuali.
La prossima sezione guarderà come funziona l'aritmetica con le date-time.

### Ottenere componenti

Puoi estrarre parti individuali della data con le funzioni accessor `year()`, `month()`, `mday()` (giorno del mese), `yday()` (giorno dell'anno), `wday()` (giorno della settimana), `hour()`, `minute()`, e `second()`.
Queste sono effettivamente l'opposto di `make_datetime()`.

```{r}
datetime <- ymd_hms("2026-07-08 12:34:56")

year(datetime)
month(datetime)
mday(datetime)

yday(datetime)
wday(datetime)
```

Per `month()` e `wday()` puoi impostare `label = TRUE` per restituire il nome abbreviato del mese o giorno della settimana.
Imposta `abbr = FALSE` per restituire il nome completo.

```{r}
month(datetime, label = TRUE)
wday(datetime, label = TRUE, abbr = FALSE)
```

Possiamo usare `wday()` per vedere che più voli partono durante la settimana che nel weekend:

```{r}
#| fig-alt: |
#|   A bar chart with days of the week on the x-axis and number of 
#|   flights on the y-axis. Monday-Friday have roughly the same number of
#|   flights, ~48,0000, decreasingly slightly over the course of the week.
#|   Sunday is a little lower (~45,000), and Saturday is much lower 
#|   (~38,000).
flights_dt |> 
  mutate(wday = wday(dep_time, label = TRUE)) |> 
  ggplot(aes(x = wday)) +
  geom_bar()
```

Possiamo anche guardare al ritardo medio di partenza per minuto all'interno dell'ora.
C'è un pattern interessante: i voli che partono nei minuti 20-30 e 50-60 hanno ritardi molto più bassi del resto dell'ora!

```{r}
#| fig-alt: | 
#|   A line chart with minute of actual departure (0-60) on the x-axis and
#|   average delay (4-20) on the y-axis. Average delay starts at (0, 12),
#|   steadily increases to (18, 20), then sharply drops, hitting at minimum
#|   at ~23 minute past the hour and 9 minutes of delay. It then increases
#|   again to (17, 35), and sharply decreases to (55, 4). It finishes off
#|   with an increase to (60, 9).
flights_dt |> 
  mutate(minute = minute(dep_time)) |> 
  group_by(minute) |> 
  summarize(
    avg_delay = mean(dep_delay, na.rm = TRUE),
    n = n()
  ) |> 
  ggplot(aes(x = minute, y = avg_delay)) +
  geom_line()
```

Interestingly, if we look at the *scheduled* departure time we don't see such a strong pattern:

```{r}
#| fig-alt: | 
#|   A line chart with minute of scheduled departure (0-60) on the x-axis
#|   and average delay (4-16). There is relatively little pattern, just a
#|   small suggestion that the average delay decreases from maybe 10 minutes
#|   to 8 minutes over the course of the hour.
sched_dep <- flights_dt |> 
  mutate(minute = minute(sched_dep_time)) |> 
  group_by(minute) |> 
  summarize(
    avg_delay = mean(arr_delay, na.rm = TRUE),
    n = n()
  )

ggplot(sched_dep, aes(x = minute, y = avg_delay)) +
  geom_line()
```

So why do we see that pattern with the actual departure times?
Well, like much data collected by humans, there's a strong bias towards flights leaving at "nice" departure times, as @fig-human-rounding shows.
Always be alert for this sort of pattern whenever you work with data that involves human judgement!

```{r}
#| label: fig-human-rounding
#| fig-cap: |
#|   A frequency polygon showing the number of flights scheduled to 
#|   depart each hour. You can see a strong preference for round numbers
#|   like 0 and 30 and generally for numbers that are a multiple of five.
#| fig-alt: |
#|   A line plot with departure minute (0-60) on the x-axis and number of
#|   flights (0-60000) on the y-axis. Most flights are scheduled to depart
#|   on either the hour (~60,000) or the half hour (~35,000). Otherwise,
#|   all most all flights are scheduled to depart on multiples of five, 
#|   with a few extra at 15, 45, and 55 minutes.
#| echo: false
ggplot(sched_dep, aes(x = minute, y = n)) +
  geom_line()
```

### Arrotondamento

Un approccio alternativo al graficamente dei componenti individuali è arrotondare la data a un'unità di tempo vicina, con `floor_date()`, `round_date()`, e `ceiling_date()`.
Ogni funzione prende un vettore di date da aggiustare e poi il nome dell'unità per arrotondare verso il basso (floor), verso l'alto (ceiling), o arrotondare.
Questo, ad esempio, ci permette di graficare il numero di voli per settimana:

```{r}
#| fig-alt: |
#|   A line plot with week (Jan-Dec 2013) on the x-axis and number of
#|   flights (2,000-7,000) on the y-axis. The pattern is fairly flat from
#|   February to November with around 7,000 flights per week. There are
#|   far fewer flights on the first (approximately 4,500 flights) and last
#|   weeks of the year (approximately 2,500 flights).
flights_dt |> 
  count(week = floor_date(dep_time, "week")) |> 
  ggplot(aes(x = week, y = n)) +
  geom_line() + 
  geom_point()
```

Puoi usare l'arrotondamento per mostrare la distribuzione dei voli durante il corso di un giorno calcolando la differenza tra `dep_time` e l'istante più presto di quel giorno:

```{r}
#| fig-alt: |
#|   A line plot with depature time on the x-axis. This is units of seconds
#|   since midnight so it's hard to interpret.
flights_dt |> 
  mutate(dep_hour = dep_time - floor_date(dep_time, "day")) |> 
  ggplot(aes(x = dep_hour)) +
  geom_freqpoly(binwidth = 60 * 30)
```

Calcolare la differenza tra una coppia di date-time produce un difftime (di più su questo in @sec-intervals).
Possiamo convertirlo in un oggetto `hms` per ottenere un asse x più utile:

```{r}
#| fig-alt: |
#|   A line plot with depature time (midnight to midnight) on the x-axis
#|   and number of flights on the y-axis (0 to 15,000). There are very few
#|   (<100) flights before 5am. The number of flights then rises rapidly 
#|   to 12,000 / hour, peaking at 15,000 at 9am, before falling to around
#|   8,000 / hour for 10am to 2pm. Number of flights then increases to
#|   around 12,000 per hour until 8pm, when they rapidly drop again. 
flights_dt |> 
  mutate(dep_hour = hms::as_hms(dep_time - floor_date(dep_time, "day"))) |> 
  ggplot(aes(x = dep_hour)) +
  geom_freqpoly(binwidth = 60 * 30)
```

### Modificare componenti

Puoi anche usare ogni funzione accessor per modificare i componenti di una date/time.
Questo non capita molto nell'analisi dei dati, ma può essere utile quando pulisci dati che hanno date chiaramente scorrette.

```{r}
(datetime <- ymd_hms("2026-07-08 12:34:56"))

year(datetime) <- 2030
datetime
month(datetime) <- 01
datetime
hour(datetime) <- hour(datetime) + 1
datetime
```

In alternativa, piuttosto che modificare una variabile esistente, puoi creare una nuova date-time con `update()`.
Questo ti permette anche di impostare valori multipli in un passo:

```{r}
update(datetime, year = 2030, month = 2, mday = 2, hour = 2)
```

Se i valori sono troppo grandi, si ribalteranno:

```{r}
update(ymd("2023-02-01"), mday = 30)
update(ymd("2023-02-01"), hour = 400)
```

### Esercizi

1.  Come cambia la distribuzione degli orari di volo all'interno di un giorno durante il corso dell'anno?

2.  Confronta `dep_time`, `sched_dep_time` e `dep_delay`.
    Sono consistenti?
    Spiega le tue scoperte.

3.  Confronta `air_time` con la durata tra partenza e arrivo.
    Spiega le tue scoperte.
    (Suggerimento: considera la posizione dell'aeroporto.)

4.  Come cambia il tempo medio di ritardo durante il corso di un giorno?
    Should you use `dep_time` or `sched_dep_time`?
    Why?

5.  On what day of the week should you leave if you want to minimise the chance of a delay?

6.  What makes the distribution of `diamonds$carat` and `flights$sched_dep_time` similar?

7.  Confirm our hypothesis that the early departures of flights in minutes 20-30 and 50-60 are caused by scheduled flights that leave early.
    Hint: create a binary variable that tells you whether or not a flight was delayed.

## Time spans

Next you'll learn about how arithmetic with dates works, including subtraction, addition, and division.
Along the way, you'll learn about three important classes that represent time spans:

-   **Durations**, which represent an exact number of seconds.
-   **Periods**, which represent human units like weeks and months.
-   **Intervals**, which represent a starting and ending point.

How do you pick between duration, periods, and intervals?
As always, pick the simplest data structure that solves your problem.
If you only care about physical time, use a duration; if you need to add human times, use a period; if you need to figure out how long a span is in human units, use an interval.

### Durations

In R, when you subtract two dates, you get a difftime object:

```{r}
# How old is Hadley?
h_age <- today() - ymd("1979-10-14")
h_age
```

A `difftime` class object records a time span of seconds, minutes, hours, days, or weeks.
This ambiguity can make difftimes a little painful to work with, so lubridate provides an alternative which always uses seconds: the **duration**.

```{r}
as.duration(h_age)
```

Durations come with a bunch of convenient constructors:

```{r}
dseconds(15)
dminutes(10)
dhours(c(12, 24))
ddays(0:5)
dweeks(3)
dyears(1)
```

Durations always record the time span in seconds.
Larger units are created by converting minutes, hours, days, weeks, and years to seconds: 60 seconds in a minute, 60 minutes in an hour, 24 hours in a day, and 7 days in a week.
Larger time units are more problematic.
A year uses the "average" number of days in a year, i.e. 365.25.
There's no way to convert a month to a duration, because there's just too much variation.

You can add and multiply durations:

```{r}
2 * dyears(1)
dyears(1) + dweeks(12) + dhours(15)
```

You can add and subtract durations to and from days:

```{r}
tomorrow <- today() + ddays(1)
last_year <- today() - dyears(1)
```

However, because durations represent an exact number of seconds, sometimes you might get an unexpected result:

```{r}
one_am <- ymd_hms("2026-03-08 01:00:00", tz = "America/New_York")

one_am
one_am + ddays(1)
```

Why is one day after 1am March 8, 2am March 9?
If you look carefully at the date you might also notice that the time zones have changed.
March 8 only has 23 hours because it's when DST starts, so if we add a full days worth of seconds we end up with a different time.

### Periods

To solve this problem, lubridate provides **periods**.
Periods are time spans but don't have a fixed length in seconds, instead they work with "human" times, like days and months.
That allows them to work in a more intuitive way:

```{r}
one_am
one_am + days(1)
```

Like durations, periods can be created with a number of friendly constructor functions.

```{r}
hours(c(12, 24))
days(7)
months(1:6)
```

You can add and multiply periods:

```{r}
10 * (months(6) + days(1))
days(50) + hours(25) + minutes(2)
```

And of course, add them to dates.
Compared to durations, periods are more likely to do what you expect:

```{r}
# A leap year
ymd("2024-01-01") + dyears(1)
ymd("2024-01-01") + years(1)

# Daylight saving time
one_am + ddays(1)
one_am + days(1)
```

Let's use periods to fix an oddity related to our flight dates.
Some planes appear to have arrived at their destination *before* they departed from New York City.

```{r}
flights_dt |> 
  filter(arr_time < dep_time) 
```

These are overnight flights.
We used the same date information for both the departure and the arrival times, but these flights arrived on the following day.
We can fix this by adding `days(1)` to the arrival time of each overnight flight.

```{r}
flights_dt <- flights_dt |> 
  mutate(
    overnight = arr_time < dep_time,
    arr_time = arr_time + days(overnight),
    sched_arr_time = sched_arr_time + days(overnight)
  )
```

Now all of our flights obey the laws of physics.

```{r}
flights_dt |> 
  filter(arr_time < dep_time) 
```

### Intervals {#sec-intervals}

What does `dyears(1) / ddays(365)` return?
It's not quite one, because `dyears()` is defined as the number of seconds per average year, which is 365.25 days.

What does `years(1) / days(1)` return?
Well, if the year was 2015 it should return 365, but if it was 2016, it should return 366!
There's not quite enough information for lubridate to give a single clear answer.
What it does instead is give an estimate:

```{r}
years(1) / days(1)
```

If you want a more accurate measurement, you'll have to use an **interval**.
An interval is a pair of starting and ending date times, or you can think of it as a duration with a starting point.

You can create an interval by writing `start %--% end`:

```{r}
y2023 <- ymd("2023-01-01") %--% ymd("2024-01-01")
y2024 <- ymd("2024-01-01") %--% ymd("2025-01-01")

y2023
y2024
```

You could then divide it by `days()` to find out how many days fit in the year:

```{r}
y2023 / days(1)
y2024 / days(1)
```

### Exercises

1.  Explain `days(!overnight)` and `days(overnight)` to someone who has just started learning R.
    What is the key fact you need to know?

2.  Create a vector of dates giving the first day of every month in 2015.
    Create a vector of dates giving the first day of every month in the *current* year.

3.  Write a function that given your birthday (as a date), returns how old you are in years.

4.  Why can't `(today() %--% (today() + years(1))) / months(1)` work?

## Time zones

Time zones are an enormously complicated topic because of their interaction with geopolitical entities.
Fortunately we don't need to dig into all the details as they're not all important for data analysis, but there are a few challenges we'll need to tackle head on.

<!--# https://www.ietf.org/timezones/tzdb-2018a/theory.html -->

The first challenge is that everyday names of time zones tend to be ambiguous.
For example, if you're American you're probably familiar with EST, or Eastern Standard Time.
However, both Australia and Canada also have EST!
To avoid confusion, R uses the international standard IANA time zones.
These use a consistent naming scheme `{area}/{location}`, typically in the form `{continent}/{city}` or `{ocean}/{city}`.
Examples include "America/New_York", "Europe/Paris", and "Pacific/Auckland".

You might wonder why the time zone uses a city, when typically you think of time zones as associated with a country or region within a country.
This is because the IANA database has to record decades worth of time zone rules.
Over the course of decades, countries change names (or break apart) fairly frequently, but city names tend to stay the same.
Another problem is that the name needs to reflect not only the current behavior, but also the complete history.
For example, there are time zones for both "America/New_York" and "America/Detroit".
These cities both currently use Eastern Standard Time but in 1969-1972 Michigan (the state in which Detroit is located), did not follow DST, so it needs a different name.
It's worth reading the raw time zone database (available at <https://www.iana.org/time-zones>) just to read some of these stories!

You can find out what R thinks your current time zone is with `Sys.timezone()`:

```{r}
Sys.timezone()
```

(If R doesn't know, you'll get an `NA`.)

And see the complete list of all time zone names with `OlsonNames()`:

```{r}
length(OlsonNames())
head(OlsonNames())
```

In R, the time zone is an attribute of the date-time that only controls printing.
For example, these three objects represent the same instant in time:

```{r}
x1 <- ymd_hms("2024-06-01 12:00:00", tz = "America/New_York")
x1

x2 <- ymd_hms("2024-06-01 18:00:00", tz = "Europe/Copenhagen")
x2

x3 <- ymd_hms("2024-06-02 04:00:00", tz = "Pacific/Auckland")
x3
```

You can verify that they're the same time using subtraction:

```{r}
x1 - x2
x1 - x3
```

Se non specificato diversamente, lubridate usa sempre UTC.
UTC (Coordinated Universal Time) è il fuso orario standard usato dalla comunità scientifica ed è approssimativamente equivalente a GMT (Greenwich Mean Time).
Non ha l'ora legale, il che rende una rappresentazione conveniente per il calcolo.
Le operazioni che combinano date-time, come `c()`, spesso elimineranno il fuso orario.
In quel caso, le date-time verranno visualizzate nel fuso orario del primo elemento:

```{r}
x4 <- c(x1, x2, x3)
x4
```

Puoi cambiare il fuso orario in due modi:

-   Mantieni l'istante nel tempo lo stesso, e cambia come viene visualizzato.
    Usa questo quando l'istante è corretto, ma vuoi una visualizzazione più naturale.

    ```{r}
    x4a <- with_tz(x4, tzone = "Australia/Lord_Howe")
    x4a
    x4a - x4
    ```

    (Questo illustra anche un'altra sfida dei fusi orari: non sono tutti offset di ore intere!)

-   Cambia l'istante sottostante nel tempo.
    Usa questo quando hai un istante che è stato etichettato con il fuso orario sbagliato, e devi correggerlo.

    ```{r}
    x4b <- force_tz(x4, tzone = "Australia/Lord_Howe")
    x4b
    x4b - x4
    ```

## Riepilogo

Questo capitolo ti ha introdotto agli strumenti che lubridate fornisce per aiutarti a lavorare con dati date-time.
Lavorare con date e orari può sembrare più difficile del necessario, ma speriamo che questo capitolo ti abbia aiutato a vedere perché --- le date-time sono più complesse di quanto sembrano a prima vista, e gestire ogni situazione possibile aggiunge complessità.
Anche se i tuoi dati non attraversano mai un confine di ora legale o coinvolgono un anno bisestile, le funzioni devono essere in grado di gestirlo.

Il prossimo capitolo fornisce un riassunto dei valori mancanti.
Li hai visti in alcuni posti e senza dubbio li hai incontrati nella tua analisi, ed è ora il momento di fornire un insieme di tecniche utili per gestirli.