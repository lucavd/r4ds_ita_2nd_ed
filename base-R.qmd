# A field guide to base R {#sec-base-r}

```{r}
#| echo: false
source("_common.R")
```

## Introduction

To finish off the programming section, we're going to give you a quick tour of the most important base R functions that we don't otherwise discuss in the book.
These tools are particularly useful as you do more programming and will help you read code you'll encounter in the wild.

This is a good place to remind you that the tidyverse is not the only way to solve data science problems.
We teach the tidyverse in this book because tidyverse packages share a common design philosophy, increasing the consistency across functions, and making each new function or package a little easier to learn and use.
It's not possible to use the tidyverse without using base R, so we've actually already taught you a **lot** of base R functions: from `library()` to load packages, to `sum()` and `mean()` for numeric summaries, to the factor, date, and POSIXct data types, and of course all the basic operators like `+`, `-`, `/`, `*`, `|`, `&`, and `!`.
What we haven't focused on so far is base R workflows, so we will highlight a few of those in this chapter.

After you read this book, you'll learn other approaches to the same problems using base R, data.table, and other packages.
You'll undoubtedly encounter these other approaches when you start reading R code written by others, particularly if you're using StackOverflow.
It's 100% okay to write code that uses a mix of approaches, and don't let anyone tell you otherwise!

In this chapter, we'll focus on four big topics: subsetting with `[`, subsetting with `[[` and `$`, the apply family of functions, and `for` loops.
To finish off, we'll briefly discuss two essential plotting functions.

### Prerequisites

This package focuses on base R so doesn't have any real prerequisites, but we'll load the tidyverse in order to explain some of the differences.

```{r}
#| label: setup
#| message: false
library(tidyverse)
```

## Selecting multiple elements with `[` {#sec-subset-many}

`[` is used to extract sub-components from vectors and data frames, and is called like `x[i]` or `x[i, j]`.
In this section, we'll introduce you to the power of `[`, first showing you how you can use it with vectors, then how the same principles extend in a straightforward way to two-dimensional (2d) structures like data frames.
We'll then help you cement that knowledge by showing how various dplyr verbs are special cases of `[`.

### Subsetting vectors

There are five main types of things that you can subset a vector with, i.e., that can be the `i` in `x[i]`:

1.  **A vector of positive integers**.
    Subsetting with positive integers keeps the elements at those positions:

    ```{r}
    x <- c("one", "two", "three", "four", "five")
    x[c(3, 2, 5)]
    ```

    By repeating a position, you can actually make a longer output than input, making the term "subsetting" a bit of a misnomer.

    ```{r}
    x[c(1, 1, 5, 5, 5, 2)]
    ```

2.  **A vector of negative integers**.
    Negative values drop the elements at the specified positions:

    ```{r}
    x[c(-1, -3, -5)]
    ```

3.  **A logical vector**.
    Subsetting with a logical vector keeps all values corresponding to a `TRUE` value.
    This is most often useful in conjunction with the comparison functions.

    ```{r}
    x <- c(10, 3, NA, 5, 8, 1, NA)

    # All non-missing values of x
    x[!is.na(x)]

    # All even (or missing!) values of x
    x[x %% 2 == 0]
    ```

    Unlike `filter()`, `NA` indices will be included in the output as `NA`s.

4.  **A character vector**.
    If you have a named vector, you can subset it with a character vector:

    ```{r}
    x <- c(abc = 1, def = 2, xyz = 5)
    x[c("xyz", "def")]
    ```

    As with subsetting with positive integers, you can use a character vector to duplicate individual entries.

5.  **Nothing**.
    The final type of subsetting is nothing, `x[]`, which returns the complete `x`.
    This is not useful for subsetting vectors, but as we'll see shortly, it is useful when subsetting 2d structures like tibbles.

### Subsetting data frames

There are quite a few different ways[^base-r-1] that you can use `[` with a data frame, but the most important way is to select rows and columns independently with `df[rows, cols]`. Here `rows` and `cols` are vectors as described above.
For example, `df[rows, ]` and `df[, cols]` select just rows or just columns, using the empty subset to preserve the other dimension.

[^base-r-1]: Read <https://adv-r.hadley.nz/subsetting.html#subset-multiple> to see how you can also subset a data frame like it is a 1d object and how you can subset it with a matrix.

Here are a couple of examples:

```{r}
df <- tibble(
  x = 1:3, 
  y = c("a", "e", "f"), 
  z = runif(3)
)

# Select first row and second column
df[1, 2]

# Select all rows and columns x and y
df[, c("x" , "y")]

# Select rows where `x` is greater than 1 and all columns
df[df$x > 1, ]
```

We'll come back to `$` shortly, but you should be able to guess what `df$x` does from the context: it extracts the `x` variable from `df`.
We need to use it here because `[` doesn't use tidy evaluation, so you need to be explicit about the source of the `x` variable.

There's an important difference between tibbles and data frames when it comes to `[`.
In this book, we've mainly used tibbles, which *are* data frames, but they tweak some behaviors to make your life a little easier.
In most places, you can use "tibble" and "data frame" interchangeably, so when we want to draw particular attention to R's built-in data frame, we'll write `data.frame`.
If `df` is a `data.frame`, then `df[, cols]` will return a vector if `col` selects a single column and a data frame if it selects more than one column.
If `df` is a tibble, then `[` will always return a tibble.

```{r}
df1 <- data.frame(x = 1:3)
df1[, "x"]

df2 <- tibble(x = 1:3)
df2[, "x"]
```

One way to avoid this ambiguity with `data.frame`s is to explicitly specify `drop = FALSE`:

```{r}
df1[, "x" , drop = FALSE]
```

### dplyr equivalents

Several dplyr verbs are special cases of `[`:

-   `filter()` is equivalent to subsetting the rows with a logical vector, taking care to exclude missing values:

    ```{r}
    #| results: false
    df <- tibble(
      x = c(2, 3, 1, 1, NA), 
      y = letters[1:5], 
      z = runif(5)
    )
    df |> filter(x > 1)

    # same as
    df[!is.na(df$x) & df$x > 1, ]
    ```

    Another common technique in the wild is to use `which()` for its side-effect of dropping missing values: `df[which(df$x > 1), ]`.

-   `arrange()` is equivalent to subsetting the rows with an integer vector, usually created with `order()`:

    ```{r}
    #| results: false
    df |> arrange(x, y)

    # same as
    df[order(df$x, df$y), ]
    ```

    You can use `order(decreasing = TRUE)` to sort all columns in descending order or `-rank(col)` to sort columns in decreasing order individually.

-   Both `select()` and `relocate()` are similar to subsetting the columns with a character vector:

    ```{r}
    #| results: false
    df |> select(x, z)

    # same as
    df[, c("x", "z")]
    ```

Base R also provides a function that combines the features of `filter()` and `select()`[^base-r-2] called `subset()`:

[^base-r-2]: But it doesn't handle grouped data frames differently and it doesn't support selection helper functions like `starts_with()`.

```{r}
df |> 
  filter(x > 1) |> 
  select(y, z)
```

```{r}
#| results: false
# same as
df |> subset(x > 1, c(y, z))
```

This function was the inspiration for much of dplyr's syntax.

### Exercises

1.  Create funzioni che prendono un vettore come input e restituiscono:

    a.  Gli elementi nelle posizioni pari.
    b.  Ogni elemento eccetto l'ultimo valore.
    c.  Solo i valori pari (e nessun valore mancante).

2.  Perché `x[-which(x > 0)]` non è uguale a `x[x <= 0]`?
    Leggete la documentazione per `which()` e fate alcuni esperimenti per capirlo.

## Selezionare un singolo elemento con `$` e `[[` {#sec-subset-one}

`[`, che seleziona molti elementi, è abbinato a `[[` e `$`, che estraggono un singolo elemento.
In questa sezione, vi mostreremo come usare `[[` e `$` per estrarre colonne dai data frame, discuteremo un paio di differenze in più tra `data.frames` e tibble, e sottolineeremo alcune differenze importanti tra `[` e `[[` quando usati con le liste.

### Data frame

`[[` e `$` possono essere usati per estrarre colonne da un data frame.
`[[` può accedere per posizione o per nome, e `$` è specializzato per l'accesso per nome:

```{r}
tb <- tibble(
  x = 1:4,
  y = c(10, 4, 1, 21)
)

# per posizione
tb[[1]]

# per nome
tb[["x"]]
tb$x
```

Possono anche essere usati per creare nuove colonne, l'equivalente base R di `mutate()`:

```{r}
tb$z <- tb$x + tb$y
tb
```

Ci sono diversi altri approcci base R per creare nuove colonne inclusi `transform()`, `with()` e `within()`.
Hadley ha raccolto alcuni esempi su <https://gist.github.com/hadley/1986a273e384fb2d4d752c18ed71bedf>.

Usare `$` direttamente è conveniente quando si eseguono riassunti veloci.
Per esempio, se volete solo trovare la dimensione del diamante più grande o i possibili valori di `cut`, non c'è bisogno di usare `summarize()`:

```{r}
max(diamonds$carat)

levels(diamonds$cut)
```

dplyr fornisce anche un equivalente a `[[`/`$` che non abbiamo menzionato in @sec-data-transform: `pull()`.
`pull()` prende un nome di variabile o una posizione di variabile e restituisce solo quella colonna.
Ciò significa che potremmo riscrivere il codice sopra per usare la pipe:

```{r}
diamonds |> pull(carat) |> max()

diamonds |> pull(cut) |> levels()
```

### Tibble

Ci sono un paio di differenze importanti tra tibble e `data.frame` base quando si tratta di `$`.
I data frame corrispondono al prefisso di qualsiasi nome di variabile (cosiddetto **partial matching**) e non si lamentano se una colonna non existe:

```{r}
df <- data.frame(x1 = 1)
df$x
df$z
```

I tibble sono più rigorosi: corrispondono solo esattamente ai nomi delle variabili e genereranno un avvertimento se la colonna a cui state cercando di accedere non esiste:

```{r}
tb <- tibble(x1 = 1)

tb$x
tb$z
```

Per questo motivo a volte scherziamo dicendo che i tibble sono pigri e scontrosi: fanno meno e si lamentano di più.

### Liste

`[[` e `$` sono anche molto importanti per lavorare con le liste, ed è importante capire come differiscono da `[`.
Illustriamo le differenze con una lista chiamata `l`:

```{r}
l <- list(
  a = 1:3, 
  b = "a string", 
  c = pi, 
  d = list(-1, -5)
)
```

-   `[` estrae una sotto-lista.
    Non importa quanti elementi estraete, il risultato sarà sempre una lista.

    ```{r}
    str(l[1:2])

    str(l[1])

    str(l[4])
    ```

    Come con i vettori, potete fare il subsetting con un vettore logico, intero o di caratteri.

-   `[[` e `$` estraggono un singolo componente da una lista.
    Rimuovono un livello di gerarchia dalla lista.

    ```{r}
    str(l[[1]])

    str(l[[4]])

    str(l$a)
    ```

La differenza tra `[` e `[[` è particolarmente importante per le liste perché `[[` penetra nella lista mentre `[` restituisce una nuova lista più piccola.
Per aiutarvi a ricordare la differenza, date un'occhiata all'insolito dosatore di pepe mostrato in @fig-pepper.
Se questo dosatore di pepe è la vostra lista `pepper`, allora `pepper[1]` è un dosatore di pepe contenente un singolo pacchetto di pepe.
`pepper[2]` sembrerebbe uguale, ma conterrebbe il secondo pacchetto.
`pepper[1:2]` sarebbe un dosatore di pepe contenente due pacchetti di pepe.
`pepper[[1]]` estrarrebbe il pacchetto di pepe stesso.

```{r}
#| label: fig-pepper
#| echo: false
#| out-width: "100%"
#| fig-cap: |
#|   (Sinistra) Un dosatore di pepe che Hadley ha trovato una volta nella sua camera d'albergo.
#|   (Centro) `pepper[1]`.
#|   (Destra) `pepper[[1]]`
#| fig-alt: |
#|   Tre foto. A sinistra c'è la foto di un dosatore di pepe di vetro. Invece di 
#|   contenere pepe, il dosatore contiene un singolo pacchetto di pepe.
#|   Al centro c'è la foto di un singolo pacchetto di pepe. A destra c'è la 
#|   foto del contenuto di un pacchetto di pepe.
knitr::include_graphics("diagrams/pepper.png")
```

Lo stesso principio si applica quando usate `[` 1d con un data frame: `df["x"]` restituisce un data frame a una colonna e `df[["x"]]` restituisce un vettore.

### Esercizi

1.  Cosa succede quando usate `[[` con un intero positivo che è più grande della lunghezza del vettore?
    Cosa succede quando fate il subsetting con un nome che non esiste?

2.  Cosa sarebbe `pepper[[1]][1]`?
    E `pepper[[1]][[1]]`?

## Famiglia apply

In @sec-iteration, avete imparato le tecniche tidyverse per l'iterazione come `dplyr::across()` e la famiglia di funzioni map.
In questa sezione, imparerete i loro equivalenti base, la **famiglia apply**.
In questo contesto apply e map sono sinonimi perché un altro modo di dire "mappa una funzione su ogni elemento di un vettore" è "applica una funzione su ogni elemento di un vettore".
Qui vi daremo una rapida panoramica di questa famiglia così potete riconoscerle nel mondo reale.

Il membro più importante di questa famiglia è `lapply()`, che è molto simile a `purrr::map()`[^base-r-3].
Infatti, poiché non abbiamo usato nessuna delle caratteristiche più avanzate di `map()`, potete sostituire ogni chiamata `map()` in @sec-iteration con `lapply()`.

[^base-r-3]: Manca solo di caratteristiche convenienti come le barre di progresso e la segnalazione di quale elemento ha causato il problema se c'è un errore.

Non c'è un equivalente base R esatto di `across()` ma potete avvicinarvi usando `[` con `lapply()`.
Questo funziona perché sotto il cofano, i data frame sono liste di colonne, quindi chiamare `lapply()` su un data frame applica la funzione a ogni colonna.

```{r}
df <- tibble(a = 1, b = 2, c = "a", d = "b", e = 4)

# Prima trova le colonne numeriche
num_cols <- sapply(df, is.numeric)
num_cols

# Poi trasforma ogni colonna con lapply() quindi sostituisci i valori originali
df[, num_cols] <- lapply(df[, num_cols, drop = FALSE], \(x) x * 2)
df
```

Il codice sopra usa una nuova funzione, `sapply()`.
È simile a `lapply()` ma cerca sempre di semplificare il risultato, da qui la `s` nel suo nome, qui producendo un vettore logico invece di una lista.
Non raccomandiamo di usarla per la programmazione, perché la semplificazione può fallire e darvi un tipo inaspettato, ma di solito va bene per l'uso interattivo.
purrr ha una funzione simile chiamata `map_vec()` che non abbiamo menzionato in @sec-iteration.

Base R fornisce una versione più rigorosa di `sapply()` chiamata `vapply()`, abbreviazione di **v**ector apply.
Prende un argomento aggiuntivo che specifica il tipo atteso, assicurando che la semplificazione avvenga allo stesso modo indipendentemente dall'input.
Per esempio, potremmo sostituire la chiamata `sapply()` sopra con questa `vapply()` dove specifichiamo che ci aspettiamo che `is.numeric()` restituisca un vettore logico di lunghezza 1:

```{r}
vapply(df, is.numeric, logical(1))
```

La distinzione tra `sapply()` e `vapply()` è molto importante quando sono dentro una funzione (perché fa una grande differenza per la robustezza della funzione agli input inusuali), ma di solito non importa nell'analisi dei dati.

Un altro membro importante della famiglia apply è `tapply()` che calcola un singolo riassunto raggruppato:

```{r}
diamonds |> 
  group_by(cut) |> 
  summarize(price = mean(price))

tapply(diamonds$price, diamonds$cut, mean)
```

Sfortunatamente `tapply()` restituisce i suoi risultati in un vettore nominato che richiede alcune acrobazie se volete raccogliere riassunti multipli e variabili di raggruppamento in un data frame (è certamente possibile non fare questo e lavorare solo con vettori liberi, ma nella nostra esperienza questo rimanda solo il lavoro).
Se volete vedere come potreste usare `tapply()` o altre tecniche base per eseguire altri riassunti raggruppati, Hadley ha raccolto alcune tecniche [in un gist](https://gist.github.com/hadley/c430501804349d382ce90754936ab8ec).

L'ultimo membro della famiglia apply è il titolare `apply()`, che funziona con matrici e array.
In particolare, fate attenzione a `apply(df, 2, something)`, che è un modo lento e potenzialmente pericoloso di fare `lapply(df, something)`.
Questo raramente emerge nella data science perché di solito lavoriamo con data frame e non matrici.

## Loop `for`

I loop `for` sono il blocco costruttivo fondamentale dell'iterazione che sia le famiglie apply che map usano sotto il cofano.
I loop `for` sono strumenti potenti e generali che è importante imparare man mano che diventate programmatori R più esperti.
La struttura di base di un loop `for` ha questo aspetto:

```{r}
#| eval: false
for (element in vector) {
  # fai qualcosa con element
}
```

L'uso più diretto dei loop `for` è raggiungere lo stesso effetto di `walk()`: chiamare qualche funzione con un effetto collaterale su ogni elemento di una lista.
Per esempio, in @sec-save-database invece di usare `walk()`:

```{r}
#| eval: false
paths |> walk(append_file)
```

Avremmo potuto usare un loop `for`:

```{r}
#| eval: false
for (path in paths) {
  append_file(path)
}
```

Le cose diventano un po' più complicate se volete salvare l'output del loop `for`, per esempio leggendo tutti i file excel in una directory come abbiamo fatto in @sec-iteration:

```{r}
paths <- dir("data/gapminder", pattern = "\\.xlsx$", full.names = TRUE)
files <- map(paths, readxl::read_excel)
```

Ci sono alcune tecniche diverse che potete usare, ma raccomandiamo di essere espliciti su come sarà l'output fin dall'inizio.
In questo caso, vogliamo una lista della stessa lunghezza di `paths`, che possiamo creare con `vector()`:

```{r}
files <- vector("list", length(paths))
```

Poi invece di iterare sugli elementi di `paths`, itereremo sui loro indici, usando `seq_along()` per generare un indice per ogni elemento di paths:

```{r}
seq_along(paths)
```

Usare gli indici è importante perché ci permette di collegare ogni posizione nell'input con la posizione corrispondente nell'output:

```{r}
for (i in seq_along(paths)) {
  files[[i]] <- readxl::read_excel(paths[[i]])
}
```

Per combinare la lista di tibble in un singolo tibble potete usare `do.call()` + `rbind()`:

```{r}
do.call(rbind, files)
```

Piuttosto che creare una lista e salvare i risultati man mano, un approccio più semplice è costruire il data frame pezzo per pezzo:

```{r}
out <- NULL
for (path in paths) {
  out <- rbind(out, readxl::read_excel(path))
}
```

Raccomandiamo di evitare questo pattern perché può diventare molto lento quando il vettore è molto lungo.
Questa è la fonte della persistente falsa credenza che i loop `for` siano lenti: non lo sono, ma far crescere iterativamente un vettore lo è.

## Grafici

Molti utenti R che non usano altrimenti il tidyverse preferiscono ggplot2 per i grafici a causa di caratteristiche utili come valori predefiniti sensati, legende automatiche e un aspetto moderno.
Tuttavia, le funzioni di plotting base R possono ancora essere utili perché sono così concise --- serve pochissima digitazione per fare un grafico esplorativo di base.

Ci sono due tipi principali di grafici base che vedrete nel mondo reale: scatterplot e istogrammi, prodotti rispettivamente con `plot()` e `hist()`.
Ecco un rapido esempio dal dataset diamonds:

```{r}
#| dev: png
#| fig-width: 4
#| fig-asp: 1
#| layout-ncol: 2
#| fig-alt: |
#|   A sinistra, istogramma dei carati dei diamanti, che va da 0 a 5 carati.
#|   La distribuzione è unimodale e asimmetrica a destra. A destra, scatter 
#|   plot di prezzo vs. carato dei diamanti, che mostra una relazione positiva 
#|   che si allarga man mano che sia il prezzo che il carato aumentano. Lo scatter plot 
#|   mostra pochissimi diamanti più grandi di 3 carati rispetto ai diamanti tra 
#|   0 e 3 carati.
# Sinistra
hist(diamonds$carat)

# Destra
plot(diamonds$carat, diamonds$price)
```

Notate che le funzioni di plotting base funzionano con i vettori, quindi dovete estrarre le colonne dal data frame usando `$` o qualche altra tecnica.

## Riassunto

In questo capitolo, vi abbiamo mostrato una selezione di funzioni base R utili per il subsetting e l'iterazione.
Rispetto agli approcci discussi altrove nel libro, queste funzioni tendono ad avere più un sapore "vettoriale" che un sapore "data frame" perché le funzioni base R tendono a prendere vettori individuali, piuttosto che un data frame e qualche specifica di colonna.
Questo spesso rende la vita più facile per la programmazione e quindi diventa più importante man mano che scrivete più funzioni e iniziate a scrivere i vostri pacchetti.

Questo capitolo conclude la sezione di programmazione del libro.
Avete fatto un solido inizio nel vostro viaggio per diventare non solo un data scientist che usa R, ma un data scientist che può *programmare* in R.
Speriamo che questi capitoli abbiano acceso il vostro interesse nella programmazione e che non vediate l'ora di imparare di più al di fuori di questo libro.