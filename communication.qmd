# Comunicazione {#sec-communication}

```{r}
#| echo: false
source("_common.R")
```

## Introduzione

In @sec-exploratory-data-analysis, hai imparato come usare i grafici come strumenti per l'*esplorazione*.
Quando fai grafici esplorativi, sai---anche prima di guardare---quali variabili il grafico mostrerà.
Hai fatto ogni grafico per uno scopo, potevi guardarlo velocemente, e poi passare al grafico successivo.
Nel corso della maggior parte delle analisi, produrrai decine o centinaia di grafici, la maggior parte dei quali vengono immediatamente buttati via.

Ora che capisci i tuoi dati, devi *comunicare* la tua comprensione ad altri.
Il tuo pubblico probabilmente non condividerà le tue conoscenze di base e non sarà profondamente coinvolto nei dati.
Per aiutare altri a costruire rapidamente un buon modello mentale dei dati, dovrai investire uno sforzo considerevole nel rendere i tuoi grafici il più auto-esplicativi possibile.
In questo capitolo, imparerai alcuni degli strumenti che ggplot2 fornisce per farlo.

Questo capitolo si concentra sugli strumenti di cui hai bisogno per creare buoni grafici.
Assumiamo che tu sappia cosa vuoi, e che tu abbia solo bisogno di sapere come farlo.
Per questa ragione, raccomandiamo vivamente di abbinare questo capitolo con un buon libro generale sulla visualizzazione.
Ci piace particolarmente [The Truthful Art](https://www.amazon.com/gp/product/0321934075/), di Albert Cairo.
Non insegna la meccanica della creazione di visualizzazioni, ma si concentra invece su quello a cui devi pensare per creare grafici efficaci.

### Prerequisiti

In questo capitolo, ci concentreremo ancora una volta su ggplot2.
Useremo anche un po' di dplyr per la manipolazione dei dati, **scales** per sovrascrivere le interruzioni, etichette, trasformazioni e palette predefinite, e alcuni pacchetti di estensione ggplot2, inclusi **ggrepel** ([https://ggrepel.slowkow.com](https://ggrepel.slowkow.com/)) di Kamil Slowikowski e **patchwork** ([https://patchwork.data-imaginist.com](https://patchwork.data-imaginist.com/)) di Thomas Lin Pedersen.
Non dimenticare che dovrai installare quei pacchetti con `install.packages()` se non li hai già.

```{r}
#| label: setup
#| message: false
library(tidyverse)
library(scales)
library(ggrepel)
library(patchwork)
```

## Etichette

Il posto più facile per iniziare quando trasformi un grafico esplorativo in un grafico esplicativo è con buone etichette.
Aggiungi etichette con la funzione `labs()`.

```{r}
#| message: false
#| fig-alt: |
#|   Scatterplot of highway fuel efficiency versus engine size of cars, where 
#|   points are colored according to the car class. A smooth curve following 
#|   the trajectory of the relationship between highway fuel efficiency versus 
#|   engine size of cars is overlaid. The x-axis is labelled "Engine 
#|   displacement (L)" and the y-axis is labelled "Highway fuel economy (mpg)". 
#|   The legend is labelled "Car type". The plot is titled "Fuel efficiency 
#|   generally decreases with engine size". The subtitle is "Two seaters 
#|   (sports cars) are an exception because of their light weight" and the 
#|   caption is "Data from fueleconomy.gov".
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  labs(
    x = "Cilindrata del motore (L)",
    y = "Economia di carburante autostradale (mpg)",
    color = "Tipo di auto",
    title = "L'efficienza del carburante generalmente diminuisce con la dimensione del motore",
    subtitle = "Le biposto (auto sportive) sono un'eccezione a causa del loro peso leggero",
    caption = "Dati da fueleconomy.gov"
  )
```

Lo scopo del titolo di un grafico è riassumere il risultato principale.
Evita titoli che descrivono solo cosa è il grafico, ad esempio, "Un grafico a dispersione della cilindrata del motore vs. economia del carburante".

Se hai bisogno di aggiungere più testo, ci sono altre due etichette utili: `subtitle` aggiunge dettagli aggiuntivi in un carattere più piccolo sotto il titolo e `caption` aggiunge testo in basso a destra del grafico, spesso usato per descrivere la fonte dei dati.
Puoi anche usare `labs()` per sostituire i titoli degli assi e delle legende.
È di solito una buona idea sostituire nomi di variabili brevi con descrizioni più dettagliate, e includere le unità.

È possibile usare equazioni matematiche invece di stringhe di testo.
Basta cambiare `""` con `quote()` e leggere le opzioni disponibili in `?plotmath`:

```{r}
#| fig-asp: 1
#| out-width: "50%"
#| fig-width: 3
#| fig-alt: |
#|   Scatterplot with math text on the x and y axis labels. X-axis label 
#|   says x_i, y-axis label says sum of x_i  squared, for i from 1 to n.
df <- tibble(
  x = 1:10,
  y = cumsum(x^2)
)

ggplot(df, aes(x, y)) +
  geom_point() +
  labs(
    x = quote(x[i]),
    y = quote(sum(x[i] ^ 2, i == 1, n))
  )
```

### Esercizi

1.  Crea un grafico sui dati dell'economia del carburante con `title`, `subtitle`, `caption`, `x`, `y` e `color` personalizzate.

2.  Ricrea il seguente grafico usando i dati dell'economia del carburante.
    Nota che sia i colori che le forme dei punti variano per tipo di trazione.

    ```{r}
    #| echo: false
    #| fig-alt: |
    #|   Scatterplot of highway versus city fuel efficiency. Shapes and 
    #|   colors of points are determined by type of drive train.
    ggplot(mpg, aes(x = cty, y = hwy, color = drv, shape = drv)) +
      geom_point() +
      labs(
        x = "MPG in città",
        y = "MPG autostradale",
        shape = "Tipo di\ntrazione",
        color = "Tipo di\ntrazione"
      )
    ```

3.  Prendi un grafico esplorativo che hai creato nell'ultimo mese e aggiungi titoli informativi per renderlo più facile da capire per gli altri.

## Annotazioni

Oltre ad etichettare i componenti principali del tuo grafico, è spesso utile etichettare osservazioni individuali o gruppi di osservazioni.
Il primo strumento che hai a disposizione è `geom_text()`.
`geom_text()` è simile a `geom_point()`, ma ha un'estetica aggiuntiva: `label`.
Questo rende possibile aggiungere etichette testuali ai tuoi grafici.

Ci sono due possibili fonti di etichette.
Primo, potresti avere un tibble che fornisce etichette.
Nel grafico seguente estraiamo le auto con la cilindrata del motore più alta in ogni tipo di trazione e salviamo le loro informazioni come un nuovo data frame chiamato `label_info`.

```{r}
label_info <- mpg |>
  group_by(drv) |>
  arrange(desc(displ)) |>
  slice_head(n = 1) |>
  mutate(
    drive_type = case_when(
      drv == "f" ~ "trazione anteriore",
      drv == "r" ~ "trazione posteriore",
      drv == "4" ~ "trazione integrale"
    )
  ) |>
  select(displ, hwy, drv, drive_type)

label_info
```

Poi, usiamo questo nuovo data frame per etichettare direttamente i tre gruppi per sostituire la legenda con etichette posizionate direttamente sul grafico.
Usando gli argomenti `fontface` e `size` possiamo personalizzare l'aspetto delle etichette di testo.
Sono più grandi del resto del testo sul grafico e in grassetto.
(`theme(legend.position = "none")` spegne tutte le legende --- ne parleremo meglio tra poco.)

```{r}
#| fig-alt: |
#|   Scatterplot of highway mileage versus engine size where points are colored 
#|   by drive type. Smooth curves for each drive type are overlaid. 
#|   Text labels identify the curves as front-wheel, rear-wheel, and 4-wheel.
ggplot(mpg, aes(x = displ, y = hwy, color = drv)) +
  geom_point(alpha = 0.3) +
  geom_smooth(se = FALSE) +
  geom_text(
    data = label_info, 
    aes(x = displ, y = hwy, label = drive_type),
    fontface = "bold", size = 5, hjust = "right", vjust = "bottom"
  ) +
  theme(legend.position = "none")
```

Nota l'uso di `hjust` (giustificazione orizzontale) e `vjust` (giustificazione verticale) per controllare l'allineamento dell'etichetta.

Tuttavia il grafico annotato che abbiamo fatto sopra è difficile da leggere perché le etichette si sovrappongono tra loro e con i punti.
Possiamo usare la funzione `geom_label_repel()` dal pacchetto ggrepel per affrontare entrambi questi problemi.
Questo utile pacchetto regolerà automaticamente le etichette in modo che non si sovrappongano:

```{r}
#| fig-alt: |
#|   Scatterplot of highway mileage versus engine size where points are colored 
#|   by drive type. Smooth curves for each drive type are overlaid. 
#|   Text labels identify the curves as front-wheel, rear-wheel, and 4-wheel.
#|   The labels are box with white background 
#|   and positioned to not overlap.
ggplot(mpg, aes(x = displ, y = hwy, color = drv)) +
  geom_point(alpha = 0.3) +
  geom_smooth(se = FALSE) +
  geom_label_repel(
    data = label_info, 
    aes(x = displ, y = hwy, label = drive_type),
    fontface = "bold", size = 5, nudge_y = 2
  ) +
  theme(legend.position = "none")
```

Puoi anche usare la stessa idea per evidenziare certi punti su un grafico con `geom_text_repel()` dal pacchetto ggrepel.
Nota un'altra tecnica utile usata qui: abbiamo aggiunto un secondo strato di punti grandi e vuoti per evidenziare ulteriormente i punti etichettati.

```{r}
#| fig-alt: |
#|   Scatterplot of highway fuel efficiency versus engine size of cars. Points 
#|   where highway mileage is above 40 as well as above 20 with engine size 
#|   above 5 are red, with a hollow red circle, and labelled with model name 
#|   of the car.
potential_outliers <- mpg |>
  filter(hwy > 40 | (hwy > 20 & displ > 5))
  
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() +
  geom_text_repel(data = potential_outliers, aes(label = model)) +
  geom_point(data = potential_outliers, color = "red") +
  geom_point(
    data = potential_outliers,
    color = "red", size = 3, shape = "circle open"
  )
```

Ricorda, oltre a `geom_text()` e `geom_label()`, hai molti altri geom in ggplot2 disponibili per aiutare ad annotare il tuo grafico.
Un paio di idee:

-   Usa `geom_hline()` e `geom_vline()` per aggiungere linee di riferimento.
    Spesso le rendiamo spesse (`linewidth = 2`) e bianche (`color = white`), e le disegniamo sotto il livello di dati primario.
    Questo le rende facili da vedere, senza distogliere l'attenzione dai dati.

-   Usa `geom_rect()` per disegnare un rettangolo attorno ai punti di interesse.
    I confini del rettangolo sono definiti dalle estetiche `xmin`, `xmax`, `ymin`, `ymax`.
    In alternativa, guarda il [pacchetto ggforce](https://ggforce.data-imaginist.com/index.html), specificamente [`geom_mark_hull()`](https://ggforce.data-imaginist.com/reference/geom_mark_hull.html), che ti permette di annotare sottoinsiemi di punti con involucri.

-   Usa `geom_segment()` con l'argomento `arrow` per attirare l'attenzione su un punto con una freccia.
    Usa le estetiche `x` e `y` per definire la posizione di partenza, e `xend` e `yend` per definire la posizione finale.

Un'altra funzione utile per aggiungere annotazioni ai grafici è `annotate()`.
Come regola pratica, i geom sono generalmente utili per evidenziare un sottoinsieme di dati mentre `annotate()` è utile per aggiungere uno o pochi elementi di annotazione a un grafico.

Per dimostrare l'uso di `annotate()`, creiamo del testo da aggiungere al nostro grafico.
Il testo è un po' lungo, quindi useremo `stringr::str_wrap()` per aggiungere automaticamente interruzioni di riga dato il numero di caratteri che vuoi per riga:

```{r}
trend_text <- "Motori più grandi tendono ad avere un'economia di carburante inferiore." |>
  str_wrap(width = 30)
trend_text
```

Poi, aggiungiamo due livelli di annotazione: uno con un geom label e l'altro con un geom segment.
Le estetiche `x` e `y` in entrambi definiscono dove l'annotazione dovrebbe iniziare, e le estetiche `xend` e `yend` nell'annotazione del segmento definiscono la posizione finale del segmento.
Nota anche che il segmento è stilizzato come una freccia.

```{r}
#| fig-alt: |
#|   Scatterplot of highway fuel efficiency versus engine size of cars. A red 
#|   arrow pointing down follows the trend of the points and the annotation 
#|   placed next to the arrow reads "Larger engine sizes tend to have lower 
#|   fuel economy". The arrow and the annotation text is red.
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() +
  annotate(
    geom = "label", x = 3.5, y = 38,
    label = trend_text,
    hjust = "left", color = "red"
  ) +
  annotate(
    geom = "segment",
    x = 3, y = 35, xend = 5, yend = 25, color = "red",
    arrow = arrow(type = "closed")
  )
```

L'annotazione è uno strumento potente per comunicare i punti chiave e le caratteristiche interessanti delle tue visualizzazioni.
L'unico limite è la tua immaginazione (e la tua pazienza nel posizionare le annotazioni per essere esteticamente piacevoli)!

### Esercizi

1.  Usa `geom_text()` con posizioni infinite per posizionare testo ai quattro angoli del grafico.

2.  Usa `annotate()` per aggiungere un geom point al centro del tuo ultimo grafico senza dover creare un tibble.
    Personalizza la forma, dimensione o colore del punto.

3.  Come interagiscono le etichette con `geom_text()` con il faceting?
    Come puoi aggiungere un'etichetta a un singolo pannello?
    Come puoi mettere un'etichetta diversa in ogni pannello?
    (Suggerimento: Pensa al dataset che viene passato a `geom_text()`.)

4.  Quali argomenti di `geom_label()` controllano l'aspetto della casella di sfondo?

5.  Quali sono i quattro argomenti di `arrow()`?
    Come funzionano?
    Crea una serie di grafici che dimostri le opzioni più importanti.

## Scale

Il terzo modo per rendere il tuo grafico migliore per la comunicazione è regolare le scale.
Le scale controllano come le mappature estetiche si manifestano visivamente.

### Scale predefinite

Normalmente, ggplot2 aggiunge automaticamente le scale per te.
Per esempio, quando digiti:

```{r}
#| label: default-scales
#| fig-show: hide
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = class))
```

ggplot2 aggiunge automaticamente le scale predefinite dietro le quinte:

```{r}
#| fig-show: hide
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = class)) +
  scale_x_continuous() +
  scale_y_continuous() +
  scale_color_discrete()
```

Nota lo schema di denominazione per le scale: `scale_` seguito dal nome dell'estetica, poi `_`, poi il nome della scala.
Le scale predefinite sono nominate secondo il tipo di variabile con cui si allineano: continuous, discrete, datetime, o date.
`scale_x_continuous()` mette i valori numerici da `displ` su una linea numerica continua sull'asse x, `scale_color_discrete()` sceglie colori per ciascuna `class` di auto, ecc.
Ci sono molte scale non predefinite di cui imparerai qui sotto.

Le scale predefinite sono state scelte con cura per fare un buon lavoro per un'ampia gamma di input.
Tuttavia, potresti voler sovrascrivere le impostazioni predefinite per due motivi:

-   Potresti voler regolare alcuni parametri della scala predefinita.
    Questo ti permette di fare cose come cambiare le interruzioni sugli assi, o le etichette chiave sulla legenda.

-   Potresti voler sostituire completamente la scala, e usare un algoritmo completamente diverso.
    Spesso puoi fare meglio del predefinito perché conosci di più sui dati.

### Tick degli assi e chiavi della legenda

Collettivamente assi e legende sono chiamati **guide**.
Gli assi sono usati per le estetiche x e y; le legende sono usate per tutto il resto.

Ci sono due argomenti principali che influenzano l'aspetto dei tick sugli assi e delle chiavi sulla legenda: `breaks` e `labels`.
Breaks controlla la posizione dei tick, o i valori associati alle chiavi.
Labels controlla l'etichetta di testo associata a ogni tick/chiave.
L'uso più comune di `breaks` è sovrascrivere la scelta predefinita:

```{r}
#| fig-alt: |
#|   Scatterplot of highway fuel efficiency versus engine size of cars,
#|   colored by drive. The y-axis has breaks starting at 15 and ending at 40, 
#|   increasing by 5.
ggplot(mpg, aes(x = displ, y = hwy, color = drv)) +
  geom_point() +
  scale_y_continuous(breaks = seq(15, 40, by = 5)) 
```

Puoi usare `labels` nello stesso modo (un vettore di caratteri della stessa lunghezza di `breaks`), ma puoi anche impostarlo su `NULL` per sopprimere completamente le etichette.
Questo può essere utile per le mappe, o per pubblicare grafici dove non puoi condividere i numeri assoluti.
Puoi anche usare `breaks` e `labels` per controllare l'aspetto delle legende.
Per le scale discrete per variabili categoriche, `labels` può essere una lista nominata dei nomi di livello esistenti e delle etichette desiderate per essi.

```{r}
#| fig-alt: |
#|   Scatterplot of highway fuel efficiency versus engine size of cars, colored 
#|   by drive. The x and y-axes do not have any labels at the axis ticks. 
#|   The legend has custom labels: 4-wheel, front, rear.
ggplot(mpg, aes(x = displ, y = hwy, color = drv)) +
  geom_point() +
  scale_x_continuous(labels = NULL) +
  scale_y_continuous(labels = NULL) +
  scale_color_discrete(labels = c("4" = "integrale", "f" = "anteriore", "r" = "posteriore"))
```

L'argomento `labels` accoppiato con le funzioni di etichettatura dal pacchetto scales è anche utile per formattare i numeri come valuta, percentuale, ecc.
Il grafico a sinistra mostra l'etichettatura predefinita con `label_dollar()`, che aggiunge un simbolo del dollaro così come una virgola separatrice delle migliaia.
Il grafico a destra aggiunge ulteriore personalizzazione dividendo i valori in dollari per 1.000 e aggiungendo un suffisso "K" (per "migliaia") così come aggiungendo interruzioni personalizzate.
Nota che `breaks` è nella scala originale dei dati.

```{r}
#| layout-ncol: 2
#| fig-width: 4
#| fig-alt: |
#|   Two side-by-side box plots of price versus cut of diamonds. The outliers 
#|   are transparent. On both plots the x-axis labels are formatted as dollars.
#|   The x-axis labels on the left plot start at $0 and go to $15,000, increasing 
#|   by $5,000. The x-axis labels on the right plot start at $1K and go to 
#|   $19K, increasing by $6K. 
# Left
ggplot(diamonds, aes(x = price, y = cut)) +
  geom_boxplot(alpha = 0.05) +
  scale_x_continuous(labels = label_dollar())

# Right
ggplot(diamonds, aes(x = price, y = cut)) +
  geom_boxplot(alpha = 0.05) +
  scale_x_continuous(
    labels = label_dollar(scale = 1/1000, suffix = "K"), 
    breaks = seq(1000, 19000, by = 6000)
  )
```

Un'altra funzione di etichettatura utile è `label_percent()`:

```{r}
#| fig-alt: |
#|   Segmented bar plots of cut, filled with levels of clarity. The y-axis 
#|   labels start at 0% and go to 100%, increasing by 25%. The y-axis label 
#|   name is "Percentage".
ggplot(diamonds, aes(x = cut, fill = clarity)) +
  geom_bar(position = "fill") +
  scale_y_continuous(name = "Percentage", labels = label_percent())
```

Un altro uso di `breaks` è quando hai relativamente pochi punti dati e vuoi evidenziare esattamente dove si verificano le osservazioni.
Per esempio, prendi questo grafico che mostra quando ogni presidente degli Stati Uniti ha iniziato e finito il suo mandato.

```{r}
#| fig-alt: |
#|   Line plot of id number of presidents versus the year they started their 
#|   presidency. Start year is marked with a point and a segment that starts 
#|   there and ends at the end of the presidency. The x-axis labels are 
#|   formatted as two digit years starting with an apostrophe, e.g., '53.
presidential |>
  mutate(id = 33 + row_number()) |>
  ggplot(aes(x = start, y = id)) +
  geom_point() +
  geom_segment(aes(xend = end, yend = id)) +
  scale_x_date(name = NULL, breaks = presidential$start, date_labels = "'%y")
```

Nota che per l'argomento `breaks` abbiamo estratto la variabile `start` come vettore con `presidential$start` perché non possiamo fare una mappatura estetica per questo argomento.
Nota anche che la specificazione di breaks e labels per le scale di date e datetime è un po' diversa:

-   `date_labels` prende una specificazione di formato, nella stessa forma di `parse_datetime()`.

-   `date_breaks` (non mostrato qui), prende una stringa come "2 days" o "1 month".

### Layout della legenda

Userai più spesso `breaks` e `labels` per regolare gli assi.
Mentre entrambi funzionano anche per le legende, ci sono alcune altre tecniche che è più probabile che userai.

Per controllare la posizione complessiva della legenda, devi usare un'impostazione di `theme()`.
Torneremo sui temi alla fine del capitolo, ma in breve, controllano le parti non-dati del grafico.
L'impostazione del tema `legend.position` controlla dove viene disegnata la legenda:

```{r}
#| layout-ncol: 2
#| fig-width: 4
#| fig-alt: |
#|   Four scatterplots of highway fuel efficiency versus engine size of cars 
#|   where points are colored based on class of car. Clockwise, the legend 
#|   is placed on the right, left, bottom, and top of the plot.
base <- ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = class))

base + theme(legend.position = "right") # il predefinito
base + theme(legend.position = "left")
base + 
  theme(legend.position = "top") +
  guides(color = guide_legend(nrow = 3))
base + 
  theme(legend.position = "bottom") +
  guides(color = guide_legend(nrow = 3))
```

Se il tuo grafico è basso e largo, posiziona la legenda in alto o in basso, e se è alto e stretto, posiziona la legenda a sinistra o a destra.
Puoi anche usare `legend.position = "none"` per sopprimere completamente la visualizzazione della legenda.

Per controllare la visualizzazione delle singole legende, usa `guides()` insieme a `guide_legend()` o `guide_colorbar()`.
Il seguente esempio mostra due impostazioni importanti: controllare il numero di righe che la legenda usa con `nrow`, e sovrascrivere una delle estetiche per rendere i punti più grandi.
Questo è particolarmente utile se hai usato un `alpha` basso per visualizzare molti punti su un grafico.

```{r}
#| fig-alt: |
#|   Scatterplot of highway fuel efficiency versus engine size of cars 
#|   where points are colored based on class of car. Overlaid on the plot is a 
#|   smooth curve. The legend is in the bottom and classes are listed 
#|   horizontally in two rows. The points in the legend are larger than the points 
#|   in the plot.
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme(legend.position = "bottom") +
  guides(color = guide_legend(nrow = 2, override.aes = list(size = 4)))
```

Nota che il nome dell'argomento in `guides()` corrisponde al nome dell'estetica, proprio come in `labs()`.

### Sostituire una scala

Invece di regolare solo un po' i dettagli, puoi invece sostituire completamente la scala.
Ci sono due tipi di scale che probabilmente vorrai cambiare: scale di posizione continue e scale di colore.
Fortunatamente, gli stessi principi si applicano a tutte le altre estetiche, quindi una volta che avrai padroneggiato posizione e colore, sarai in grado di imparare rapidamente altre sostituzioni di scale.

È molto utile tracciare trasformazioni della tua variabile.
Per esempio, è più facile vedere la relazione precisa tra `carat` e `price` se le trasformiamo logaritmicamente:

```{r}
#| fig-align: default
#| layout-ncol: 2
#| fig-width: 3
#| fig-alt: |
#|   Two plots of price versus carat of diamonds. Data binned and the color of 
#|   the rectangles representing each bin based on the number of points that 
#|   fall into that bin. In the plot on the right, price and carat values 
#|   are logged and the axis labels shows the logged values.
# Left
ggplot(diamonds, aes(x = carat, y = price)) +
  geom_bin2d()

# Right
ggplot(diamonds, aes(x = log10(carat), y = log10(price))) +
  geom_bin2d()
```

Tuttavia, lo svantaggio di questa trasformazione è che gli assi sono ora etichettati con i valori trasformati, rendendo difficile interpretare il grafico.
Invece di fare la trasformazione nella mappatura estetica, possiamo invece farla con la scala.
Questo è visualmente identico, tranne che gli assi sono etichettati sulla scala di dati originale.

```{r}
#| fig-alt: |
#|   Plot of price versus carat of diamonds. Data binned and the color of 
#|   the rectangles representing each bin based on the number of points that 
#|   fall into that bin. The axis labels are on the original data scale.
ggplot(diamonds, aes(x = carat, y = price)) +
  geom_bin2d() + 
  scale_x_log10() + 
  scale_y_log10()
```

Un'altra scala che viene spesso personalizzata è il colore.
La scala categorica predefinita sceglie colori che sono distribuiti uniformemente attorno alla ruota dei colori.
Alternative utili sono le scale ColorBrewer che sono state regolate manualmente per funzionare meglio per persone con tipi comuni di daltonismo.
I due grafici qui sotto sembrano simili, ma c'è abbastanza differenza nelle sfumature di rosso e verde che i punti a destra possono essere distinti anche da persone con daltonismo rosso-verde.[^communication-1]

[^communication-1]: Puoi usare uno strumento come [SimDaltonism](https://michelf.ca/projects/sim-daltonism/) per simulare il daltonismo per testare queste immagini.

```{r}
#| fig-align: default
#| layout-ncol: 2
#| fig-width: 3
#| fig-alt: |
#|   Two scatterplots of highway mileage versus engine size where points are 
#|   colored by drive type. The plot on the left uses the default 
#|   ggplot2 color palette and the plot on the right uses a different color 
#|   palette.
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = drv))

ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = drv)) +
  scale_color_brewer(palette = "Set1")
```

Non dimenticare tecniche più semplici per migliorare l'accessibilità.
Se ci sono solo pochi colori, puoi aggiungere una mappatura di forma ridondante.
Questo aiuterà anche ad assicurare che il tuo grafico sia interpretabile in bianco e nero.

```{r}
#| fig-alt: |
#|   Scatterplot of highway mileage versus engine size where both color 
#|   and shape of points are based on drive type. The color palette is not 
#|   the default ggplot2 palette.
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = drv, shape = drv)) +
  scale_color_brewer(palette = "Set1")
```

Le scale ColorBrewer sono documentate online su <https://colorbrewer2.org/> e rese disponibili in R tramite il pacchetto **RColorBrewer**, di Erich Neuwirth.
@fig-brewer mostra la lista completa di tutte le palette.
Le palette sequenziali (in alto) e divergenti (in basso) sono particolarmente utili se i tuoi valori categorici sono ordinati, o hanno un "centro".
Questo si verifica spesso se hai usato `cut()` per trasformare una variabile continua in una variabile categorica.

```{r}
#| label: fig-brewer
#| echo: false
#| fig-cap: All colorBrewer scales.
#| fig-asp: 2.5
#| fig-alt: |
#|   All colorBrewer scales. One group goes from light to dark colors. 
#|   Another group is a set of non ordinal colors. And the last group has 
#|   diverging scales (from dark to light to dark again). Within each set 
#|   there are a number of palettes.
par(mar = c(0, 3, 0, 0))
RColorBrewer::display.brewer.all()
```

Quando hai una mappatura predefinita tra valori e colori, usa `scale_color_manual()`.
Per esempio, se mappiamo il partito presidenziale al colore, vogliamo usare la mappatura standard di rosso per i Repubblicani e blu per i Democratici.
Un approccio per assegnare questi colori è usare codici colore esadecimali:

```{r}
#| fig-alt: |
#|   Line plot of id number of presidents versus the year they started their 
#|   presidency. Start year is marked with a point and a segment that starts 
#|   there and ends at the end of the presidency. Democratic presidents are 
#|   represented in blue and Republicans in red.
presidential |>
  mutate(id = 33 + row_number()) |>
  ggplot(aes(x = start, y = id, color = party)) +
  geom_point() +
  geom_segment(aes(xend = end, yend = id)) +
  scale_color_manual(values = c(Republican = "#E81B23", Democratic = "#00AEF3"))
```

Per il colore continuo, puoi usare `scale_color_gradient()` o `scale_fill_gradient()` incorporati.
Se hai una scala divergente, puoi usare `scale_color_gradient2()`.
Questo ti permette di dare, per esempio, colori diversi ai valori positivi e negativi.
È a volte utile anche se vuoi distinguere punti sopra o sotto la media.

Un'altra opzione è usare le scale di colore viridis.
I progettisti, Nathaniel Smith e Stéfan van der Walt, hanno realizzato con cura schemi di colore continui che sono percepibili alle persone con varie forme di daltonismo così come percettivamente uniformi sia a colori che in bianco e nero.
Queste scale sono disponibili come palette continue (`c`), discrete (`d`), e binned (`b`) in ggplot2.

```{r}
#| fig-align: default
#| layout-ncol: 2
#| fig-width: 3
#| fig-asp: 0.75
#| fig-alt: |
#|   Three hex plots where the color of the hexes show the number of observations 
#|   that fall into that hex bin. The first plot uses the default, continuous 
#|   ggplot2 scale. The second plot uses the viridis, continuous scale, and the 
#|   third plot uses the viridis, binned scale.
df <- tibble(
  x = rnorm(10000),
  y = rnorm(10000)
)

ggplot(df, aes(x, y)) +
  geom_hex() +
  coord_fixed() +
  labs(title = "Default, continuous", x = NULL, y = NULL)

ggplot(df, aes(x, y)) +
  geom_hex() +
  coord_fixed() +
  scale_fill_viridis_c() +
  labs(title = "Viridis, continuous", x = NULL, y = NULL)

ggplot(df, aes(x, y)) +
  geom_hex() +
  coord_fixed() +
  scale_fill_viridis_b() +
  labs(title = "Viridis, binned", x = NULL, y = NULL)
```

Nota che tutte le scale di colore vengono in due varietà: `scale_color_*()` e `scale_fill_*()` per le estetiche `color` e `fill` rispettivamente (le scale di colore sono disponibili sia con l'ortografia UK che US).

### Zoom

Ci sono tre modi per controllare i limiti del grafico:

1.  Regolare quali dati vengono tracciati.
2.  Impostare i limiti in ogni scala.
3.  Impostare `xlim` e `ylim` in `coord_cartesian()`.

Dimostreremo queste opzioni in una serie di grafici.
Il grafico a sinistra mostra la relazione tra dimensione del motore ed efficienza del carburante, colorato per tipo di trazione.
Il grafico a destra mostra le stesse variabili, ma sottoinsiemi dei dati che vengono tracciati.
Il sottoinsieme dei dati ha influenzato le scale x e y così come la curva di lisciamento.

```{r}
#| layout-ncol: 2
#| fig-width: 4
#| message: false
#| fig-alt: |
#|   On the left, scatterplot of highway mileage vs. displacement 
#|   where points are colored by drive type. 
#|   The smooth curve overlaid shows a decreasing, and then 
#|   increasing trend, like a hockey stick. On the right, same variables 
#|   are plotted with displacement ranging only from 5 to 6 and highway 
#|   mileage ranging only from 10 to 25. The smooth curve overlaid shows a 
#|   trend that's slightly increasing first and then decreasing. 
# Left
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = drv)) +
  geom_smooth()

# Right
mpg |>
  filter(displ >= 5 & displ <= 6 & hwy >= 10 & hwy <= 25) |>
  ggplot(aes(x = displ, y = hwy)) +
  geom_point(aes(color = drv)) +
  geom_smooth()
```

Confrontiamo questi con i due grafici qui sotto dove il grafico a sinistra imposta i `limits` sulle singole scale e il grafico a destra li imposta in `coord_cartesian()`.
Possiamo vedere che ridurre i limiti è equivalente al sottoinsieme dei dati.
Pertanto, per ingrandire una regione del grafico, è generalmente meglio usare `coord_cartesian()`.

```{r}
#| layout-ncol: 2
#| fig-width: 4
#| message: false
#| warning: false
#| fig-alt: |
#|   On the left, scatterplot of highway mileage vs. displacement, with 
#|   displacement ranging from 5 to 6 and highway mileage ranging from 
#|   10 to 25. The smooth curve overlaid shows a trend that's slightly 
#|   increasing first and then decreasing. On the right, same variables 
#|   are plotted with the same limits, however the smooth curve overlaid
#|   shows a relatively flat trend with a slight increase at the end.
# Left
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = drv)) +
  geom_smooth() +
  scale_x_continuous(limits = c(5, 6)) +
  scale_y_continuous(limits = c(10, 25))

# Right
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = drv)) +
  geom_smooth() +
  coord_cartesian(xlim = c(5, 6), ylim = c(10, 25))
```

D'altra parte, impostare i `limits` sulle singole scale è generalmente più utile se vuoi *espandere* i limiti, ad esempio, per abbinare le scale tra grafici diversi.
Per esempio, se estraiamo due classi di auto e le tracciamo separatamente, è difficile confrontare i grafici perché tutte e tre le scale (l'asse x, l'asse y, e l'estetica del colore) hanno range diversi.

```{r}
#| layout-ncol: 2
#| fig-width: 4
#| fig-alt: |
#|   On the left, a scatterplot of highway mileage vs. displacement of SUVs.
#|   On the right, a scatterplot of the same variables for compact cars.
#|   Points are colored by drive type for both plots. Among SUVs more of 
#|   the cars are 4-wheel drive and the others are rear-wheel drive, while 
#|   among compact cars more of the cars are front-wheel drive and the others 
#|   are 4-wheel drive. SUV plot shows a clear negative relationship 
#|   between higway mileage and displacement while in the compact cars plot 
#|   the relationship is much flatter.
suv <- mpg |> filter(class == "suv")
compact <- mpg |> filter(class == "compact")

# Left
ggplot(suv, aes(x = displ, y = hwy, color = drv)) +
  geom_point()

# Right
ggplot(compact, aes(x = displ, y = hwy, color = drv)) +
  geom_point()
```

Un modo per superare questo problema è condividere le scale tra grafici multipli, addestrando le scale con i `limits` dei dati completi.

```{r}
#| layout-ncol: 2
#| fig-width: 4
#| fig-alt: |
#|   On the left, a scatterplot of highway mileage vs. displacement of SUVs.
#|   On the right, a scatterplot of the same variables for compact cars.
#|   Points are colored by drive type for both plots. Both plots are plotted 
#|   on the same scale for highway mileage, displacement, and drive type, 
#|   resulting in the legend showing all three types (front, rear, and 4-wheel 
#|   drive) for both plots even though there are no front-wheel drive SUVs and 
#|   no rear-wheel drive compact cars. Since the x and y scales are the same, 
#|   and go well beyond minimum or maximum highway mileage and displacement, 
#|   the points do not take up the entire plotting area.
x_scale <- scale_x_continuous(limits = range(mpg$displ))
y_scale <- scale_y_continuous(limits = range(mpg$hwy))
col_scale <- scale_color_discrete(limits = unique(mpg$drv))

# Left
ggplot(suv, aes(x = displ, y = hwy, color = drv)) +
  geom_point() +
  x_scale +
  y_scale +
  col_scale

# Right
ggplot(compact, aes(x = displ, y = hwy, color = drv)) +
  geom_point() +
  x_scale +
  y_scale +
  col_scale
```

In questo caso particolare, avresti potuto semplicemente usare il faceting, ma questa tecnica è utile più in generale, se per esempio, vuoi distribuire grafici su pagine multiple di un report.

### Esercizi

1.  Perché il seguente codice non sovrascrive la scala predefinita?

    ```{r}
    #| fig-show: hide
    df <- tibble(
      x = rnorm(10000),
      y = rnorm(10000)
    )

    ggplot(df, aes(x, y)) +
      geom_hex() +
      scale_color_gradient(low = "white", high = "red") +
      coord_fixed()
    ```

2.  Qual è il primo argomento di ogni scala?
    Come si confronta con `labs()`?

3.  Cambia la visualizzazione dei mandati presidenziali:

    a.  Combinando le due varianti che personalizzano colori e interruzioni dell'asse x.
    b.  Migliorando la visualizzazione dell'asse y.
    c.  Etichettando ogni mandato con il nome del presidente.
    d.  Aggiungendo etichette informative del grafico.
    e.  Posizionando interruzioni ogni 4 anni (questo è più complicato di quanto sembri!).

4.  Prima, crea il seguente grafico.
    Poi, modifica il codice usando `override.aes` per rendere la legenda più facile da vedere.

    ```{r}
    #| fig-show: hide
    ggplot(diamonds, aes(x = carat, y = price)) +
      geom_point(aes(color = cut), alpha = 1/20)
    ```

## Temi {#sec-themes}

Infine, puoi personalizzare gli elementi non-dati del tuo grafico con un tema:

```{r}
#| message: false
#| fig-alt: |
#|   Scatterplot of highway mileage vs. displacement of cars, colored by class 
#|   of car. The plot background is white, with gray grid lines.
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_bw()
```

ggplot2 include gli otto temi mostrati in @fig-themes, con `theme_gray()` come predefinito.[^communication-2]
Molti altri sono inclusi in pacchetti aggiuntivi come **ggthemes** (<https://jrnold.github.io/ggthemes>), di Jeffrey Arnold.
Puoi anche creare i tuoi temi, se stai cercando di abbinare un particolare stile aziendale o di rivista.

[^communication-2]: Molte persone si chiedono perché il tema predefinito abbia uno sfondo grigio.
    Questa è stata una scelta deliberata perché mette i dati in primo piano mantenendo comunque visibili le linee della griglia.
    Le linee bianche della griglia sono visibili (il che è importante perché aiutano significativamente i giudizi di posizione), ma hanno poco impatto visivo e possiamo facilmente ignorarle.
    Lo sfondo grigio dà al grafico un colore tipografico simile al testo, assicurando che i grafici si inseriscano nel flusso di un documento senza risaltare con uno sfondo bianco brillante.
    Infine, lo sfondo grigio crea un campo continuo di colore che assicura che il grafico sia percepito come una singola entità visiva.

```{r}
#| label: fig-themes
#| echo: false
#| fig-cap: The eight themes built-in to ggplot2.
#| fig-alt: |
#|   Eight barplots created with ggplot2, each 
#|   with one of the eight built-in themes: 
#|   theme_bw() - White background with grid lines,
#|   theme_light() - Light axes and grid lines,
#|   theme_classic() - Classic theme, axes but no grid
#|   lines, theme_linedraw() - Only black lines, 
#|   theme_dark() - Dark background for contrast, 
#|   theme_minimal() - Minimal theme, no background,
#|   theme_gray() - Gray background (default theme),
#|   theme_void() - Empty theme, only geoms are visible.
knitr::include_graphics("images/visualization-themes.png")
```

È anche possibile controllare componenti individuali di ogni tema, come la dimensione e il colore del carattere usato per l'asse y.
Abbiamo già visto che `legend.position` controlla dove viene disegnata la legenda.
Ci sono molti altri aspetti della legenda che possono essere personalizzati con `theme()`.
Per esempio, nel grafico sotto cambiamo la direzione della legenda così come mettiamo un bordo nero attorno ad essa.
Nota che la personalizzazione degli elementi della casella della legenda e del titolo del grafico del tema è fatta con le funzioni `element_*()`.
Queste funzioni specificano lo stile dei componenti non-dati, ad esempio, il testo del titolo è in grassetto nell'argomento `face` di `element_text()` e il colore del bordo della legenda è definito nell'argomento `color` di `element_rect()`.
Gli elementi del tema che controllano la posizione del titolo e della didascalia sono `plot.title.position` e `plot.caption.position`, rispettivamente.
Nel seguente grafico questi sono impostati su `"plot"` per indicare che questi elementi sono allineati all'intera area del grafico, invece del pannello del grafico (il predefinito).
Alcuni altri componenti `theme()` utili sono usati per cambiare il posizionamento per il formato del testo del titolo e della didascalia.

```{r}
#| fig-alt: |
#|   Scatterplot of highway fuel efficiency versus engine size of cars, colored 
#|   by drive. The plot is titled 'Larger engine sizes tend to have lower fuel 
#|   economy' with the caption pointing to the source of the data, fueleconomy.gov.
#|   The caption and title are left justified, the legend is inside of the plot
#|   with a black border.
ggplot(mpg, aes(x = displ, y = hwy, color = drv)) +
  geom_point() +
  labs(
    title = "Motori più grandi tendono ad avere un'economia di carburante inferiore",
    caption = "Fonte: https://fueleconomy.gov."
  ) +
  theme(
    legend.position = c(0.6, 0.7),
    legend.direction = "horizontal",
    legend.box.background = element_rect(color = "black"),
    plot.title = element_text(face = "bold"),
    plot.title.position = "plot",
    plot.caption.position = "plot",
    plot.caption = element_text(hjust = 0)
  )
```

Per una panoramica di tutti i componenti di `theme()`, vedi l'aiuto con `?theme`.
Il [libro ggplot2](https://ggplot2-book.org/) è anche un ottimo posto dove andare per i dettagli completi sui temi.

### Esercizi

1.  Scegli un tema offerto dal pacchetto ggthemes e applicalo all'ultimo grafico che hai fatto.
2.  Rendi le etichette degli assi del tuo grafico blu e in grassetto.

## Layout

Finora abbiamo parlato di come creare e modificare un singolo grafico.
E se hai grafici multipli che vuoi disporre in un certo modo?
Il pacchetto patchwork ti permette di combinare grafici separati nello stesso grafico.
Abbiamo caricato questo pacchetto prima nel capitolo.

Per posizionare due grafici uno accanto all'altro, puoi semplicemente aggiungerli l'uno all'altro.
Nota che prima devi creare i grafici e salvarli come oggetti (nel seguente esempio sono chiamati `p1` e `p2`).
Poi, li posizioni uno accanto all'altro con `+`.

```{r}
#| fig-width: 6
#| fig-asp: 0.5
#| fig-alt: |
#|   Two plots (a scatterplot of highway mileage versus engine size and a 
#|   side-by-side boxplots of highway mileage versus drive train) placed next 
#|   to each other.
p1 <- ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point() + 
  labs(title = "Plot 1")
p2 <- ggplot(mpg, aes(x = drv, y = hwy)) + 
  geom_boxplot() + 
  labs(title = "Plot 2")
p1 + p2
```

È importante notare che nel blocco di codice sopra non abbiamo usato una nuova funzione dal pacchetto patchwork.
Invece, il pacchetto ha aggiunto una nuova funzionalità all'operatore `+`.

Puoi anche creare layout di grafici complessi con patchwork.
Nel seguente, `|` posiziona `p1` e `p3` uno accanto all'altro e `/` sposta `p2` alla riga successiva.

```{r}
#| fig-width: 6
#| fig-asp: 0.8
#| fig-alt: |
#|   Three plots laid out such that first and third plot are next to each other 
#|   and the second plot stretched beneath them. The first plot is a 
#|   scatterplot of highway mileage versus engine size, the third plot is a 
#|   scatterplot of highway mileage versus city mileage, and the second plot is 
#|   side-by-side boxplots of highway mileage versus drive train). 
p3 <- ggplot(mpg, aes(x = cty, y = hwy)) + 
  geom_point() + 
  labs(title = "Plot 3")
(p1 | p3) / p2
```

Inoltre, patchwork ti permette di raccogliere legende da grafici multipli in una legenda comune, personalizzare il posizionamento della legenda così come le dimensioni dei grafici, e aggiungere un titolo comune, sottotitolo, didascalia, ecc. ai tuoi grafici.
Sotto creiamo 5 grafici.
Abbiamo spento le legende sui box plot e lo scatterplot e raccolto le legende per i density plot in cima al grafico con `& theme(legend.position = "top")`.
Nota l'uso dell'operatore `&` qui invece del solito `+`.
Questo perché stiamo modificando il tema per il grafico patchwork contrapposto ai singoli ggplot.
La legenda è posizionata in cima, dentro la `guide_area()`.
Infine, abbiamo anche personalizzato le altezze dei vari componenti del nostro patchwork -- la guida ha un'altezza di 1, i box plot 3, density plot 2, e lo scatterplot faccettato 4.
Patchwork divide l'area che hai assegnato per il tuo grafico usando questa scala e posiziona i componenti di conseguenza.

```{r}
#| fig-width: 8
#| fig-asp: 1
#| fig-alt: |
#|   Five plots laid out such that first two plots are next to each other. Plots 
#|   three and four are underneath them. And the fifth plot stretches under them. 
#|   The patchworked plot is titled "City and highway mileage for cars with 
#|   different drive trains" and captioned "Source: https://fueleconomy.gov". 
#|   The first two plots are side-by-side box plots. Plots 3 and 4 are density 
#|   plots. And the fifth plot is a faceted scatterplot. Each of these plots show 
#|   geoms colored by drive train, but the patchworked plot has only one legend 
#|   that applies to all of them, above the plots and beneath the title.
p1 <- ggplot(mpg, aes(x = drv, y = cty, color = drv)) + 
  geom_boxplot(show.legend = FALSE) + 
  labs(title = "Plot 1")

p2 <- ggplot(mpg, aes(x = drv, y = hwy, color = drv)) + 
  geom_boxplot(show.legend = FALSE) + 
  labs(title = "Plot 2")

p3 <- ggplot(mpg, aes(x = cty, color = drv, fill = drv)) + 
  geom_density(alpha = 0.5) + 
  labs(title = "Plot 3")

p4 <- ggplot(mpg, aes(x = hwy, color = drv, fill = drv)) + 
  geom_density(alpha = 0.5) + 
  labs(title = "Plot 4")

p5 <- ggplot(mpg, aes(x = cty, y = hwy, color = drv)) + 
  geom_point(show.legend = FALSE) + 
  facet_wrap(~drv) +
  labs(title = "Plot 5")

(guide_area() / (p1 + p2) / (p3 + p4) / p5) +
  plot_annotation(
    title = "Chilometraggio urbano e autostradale per auto con diverse trazioni",
    caption = "Fonte: https://fueleconomy.gov."
  ) +
  plot_layout(
    guides = "collect",
    heights = c(1, 3, 2, 4)
    ) &
  theme(legend.position = "top")
```

Se vuoi imparare di più sulla combinazione e il layout di grafici multipli con patchwork, raccomandiamo di guardare attraverso le guide sul sito web del pacchetto: <https://patchwork.data-imaginist.com>.

### Esercizi

1.  Cosa succede se ometti le parentesi nel seguente layout di grafici?
    Puoi spiegare perché questo accade?

    ```{r}
    #| fig-show: hide
    p1 <- ggplot(mpg, aes(x = displ, y = hwy)) + 
      geom_point() + 
      labs(title = "Plot 1")
    p2 <- ggplot(mpg, aes(x = drv, y = hwy)) + 
      geom_boxplot() + 
      labs(title = "Plot 2")
    p3 <- ggplot(mpg, aes(x = cty, y = hwy)) + 
      geom_point() + 
      labs(title = "Plot 3")

    (p1 | p2) / p3
    ```

2.  Usando i tre grafici dall'esercizio precedente, ricrea il seguente patchwork.

    ```{r}
    #| fig-width: 7
    #| fig-asp: 0.8
    #| echo: false
    #| fig-alt: |
    #|   Three plots: Plot 1 is a scatterplot of highway mileage versus engine size. 
    #|   Plot 2 is side-by-side box plots of highway mileage versus drive train. 
    #|   Plot 3 is side-by-side box plots of city mileage versus drive train. 
    #|   Plots 1 is on the first row. Plots 2 and 3 are on the next row, each span 
    #|   half the width of Plot 1. Plot 1 is labelled "Fig. A", Plot 2 is labelled 
    #|   "Fig. B", and Plot 3 is labelled "Fig. C".
    p1 / (p2 + p3) +
      plot_annotation(
        tag_levels = c("A"), 
        tag_prefix = "Fig. ",
        tag_suffix = ":"
      )
    ```

## Riassunto

In questo capitolo hai imparato ad aggiungere etichette del grafico come titolo, sottotitolo, didascalia così come modificare le etichette degli assi predefinite, usare annotazioni per aggiungere testo informativo al tuo grafico o per evidenziare punti dati specifici, personalizzare le scale degli assi, e cambiare il tema del tuo grafico.
Hai anche imparato a combinare grafici multipli in un singolo grafico usando sia layout di grafici semplici che complessi.

Mentre finora hai imparato come fare molti tipi diversi di grafici e come personalizzarli usando una varietà di tecniche, abbiamo appena graffiato la superficie di quello che puoi creare con ggplot2.
Se vuoi ottenere una comprensione completa di ggplot2, raccomandiamo di leggere il libro, [*ggplot2: Elegant Graphics for Data Analysis*](https://ggplot2-book.org).
Altre risorse utili sono [*R Graphics Cookbook*](https://r-graphics.org) di Winston Chang e [*Fundamentals of Data Visualization*](https://clauswilke.com/dataviz/) di Claus Wilke.