# Visualizzazione dei dati {#sec-data-visualization}

```{r}
#| echo: false
source("_common.R")
```

## Introduzione

> "Il semplice grafico ha portato più informazioni alla mente dell'analista di dati di qualsiasi altro strumento." --- John Tukey

R ha diversi sistemi per creare grafici, ma ggplot2 è uno dei più eleganti e versatili.
ggplot2 implementa la **grammar of graphics**, un sistema coerente per descrivere e costruire grafici.
Con ggplot2 puoi fare di più e più velocemente imparando un sistema e applicandolo in molti posti.

Questo capitolo ti insegnerà come visualizzare i tuoi dati usando **ggplot2**.
Inizieremo creando un semplice scatterplot e lo useremo per introdurre le mappature estetiche e gli oggetti geometrici -- i blocchi fondamentali di ggplot2.
Poi ti guideremo attraverso la visualizzazione delle distribuzioni di singole variabili così come la visualizzazione delle relazioni tra due o più variabili.
Concluderemo con il salvare i tuoi grafici e suggerimenti per la risoluzione dei problemi.

### Prerequisiti

Questo capitolo si concentra su ggplot2, uno dei pacchetti principali nel tidyverse.
Per accedere ai dataset, alle pagine di aiuto e alle funzioni usate in questo capitolo, carica il tidyverse eseguendo:

```{r}
#| label: setup
library(tidyverse)
```

Quella singola riga di codice carica il tidyverse principale; i pacchetti che userai in quasi ogni analisi di dati.
Ti dice anche quali funzioni del tidyverse confliggono con le funzioni di R base (o da altri pacchetti che potresti aver caricato)[^data-visualize-1].

[^data-visualize-1]: Puoi eliminare quel messaggio e forzare la risoluzione dei conflitti su richiesta usando il pacchetto conflicted, che diventa più importante man mano che carichi più pacchetti.
    Puoi saperne di più su conflicted su <https://conflicted.r-lib.org>.

Se esegui questo codice e ottieni il messaggio di errore `there is no package called 'tidyverse'`, dovrai prima installarlo, poi eseguire `library()` di nuovo.

```{r}
#| eval: false
install.packages("tidyverse")
library(tidyverse)
```

Devi installare un pacchetto solo una volta, ma devi caricarlo ogni volta che inizi una nuova sessione.

Oltre al tidyverse, useremo anche il pacchetto **palmerpenguins**, che include il dataset `penguins` contenente misurazioni corporee di pinguini su tre isole nell'Arcipelago Palmer, e il pacchetto ggthemes, che offre una palette di colori sicura per i daltonici.

```{r}
library(palmerpenguins)
library(ggthemes)
```

## Primi passi

I pinguini con pinne più lunghe pesano di più o di meno dei pinguini con pinne più corte?
Probabilmente hai già una risposta, ma prova a rendere la tua risposta precisa.
Come appare la relazione tra la lunghezza delle pinne e la massa corporea?
È positiva?
Negativa?
Lineare?
Non lineare?
La relazione varia in base alla specie del pinguino?
E in base all'isola dove vive il pinguino?
Creamio visualizzazioni che possiamo usare per rispondere a queste domande.

### Il data frame `penguins`

Puoi testare le tue risposte a quelle domande con il **data frame** `penguins` che si trova in palmerpenguins (anche chiamato `palmerpenguins::penguins`).
Un data frame è una collezione rettangolare di variabili (nelle colonne) e osservazioni (nelle righe).
`penguins` contiene `r nrow(penguins)` osservazioni raccolte e rese disponibili da Dr. Kristen Gorman e Palmer Station, Antarctica LTER[^data-visualize-2].

[^data-visualize-2]: Horst AM, Hill AP, Gorman KB (2020).
    palmerpenguins: Palmer Archipelago (Antarctica) penguin data.
    R package version 0.1.0.
    <https://allisonhorst.github.io/palmerpenguins/>.
    doi: 10.5281/zenodo.3960218.

Per rendere la discussione più facile, definiamo alcuni termini:

-   Una **variabile** è una quantità, qualità o proprietà che puoi misurare.

-   Un **valore** è lo stato di una variabile quando la misuri.
    Il valore di una variabile può cambiare da misurazione a misurazione.

-   Un'**osservazione** è un insieme di misurazioni fatte in condizioni simili (di solito fai tutte le misurazioni in un'osservazione allo stesso tempo e sullo stesso oggetto).
    Un'osservazione conterrà diversi valori, ognuno associato a una variabile diversa.
    A volte ci riferiremo a un'osservazione come punto dati.

-   I **dati tabulari** sono un insieme di valori, ognuno associato a una variabile e un'osservazione.
    I dati tabulari sono *ordinati* se ogni valore è posizionato nella sua "cella", ogni variabile nella sua colonna, e ogni osservazione nella sua riga.

In questo contesto, una variabile si riferisce a un attributo di tutti i pinguini, e un'osservazione si riferisce a tutti gli attributi di un singolo pinguino.

Digita il nome del data frame nella console e R stamperà un'anteprima dei suoi contenuti.
Nota che dice `tibble` sopra questa anteprima.
Nel tidyverse, usiamo data frame speciali chiamati **tibble** di cui imparerai di più presto.

```{r}
penguins
```

Questo data frame contiene `r ncol(penguins)` colonne.
Per una vista alternativa, dove puoi vedere tutte le variabili e le prime osservazioni di ogni variabile, usa `glimpse()`.
Oppure, se sei in RStudio, esegui `View(penguins)` per aprire un visualizzatore di dati interattivo.

```{r}
glimpse(penguins)
```

Tra le variabili in `penguins` ci sono:

1.  `species`: la specie di un pinguino (Adelie, Chinstrap, o Gentoo).

2.  `flipper_length_mm`: lunghezza della pinna di un pinguino, in millimetri.

3.  `body_mass_g`: massa corporea di un pinguino, in grammi.

Per saperne di più su `penguins`, apri la sua pagina di aiuto eseguendo `?penguins`.

### Obiettivo finale {#sec-ultimate-goal}

Il nostro obiettivo finale in questo capitolo è ricreare la seguente visualizzazione che mostra la relazione tra le lunghezze delle pinne e le masse corporee di questi pinguini, prendendo in considerazione la specie del pinguino.

```{r}
#| echo: false
#| warning: false
#| fig-alt: |
#|   Un grafico a dispersione di massa corporea vs. lunghezza delle pinne di pinguini, con una
#|   linea di migliore adattamento della relazione tra queste due variabili 
#|   sovrapposta. Il grafico mostra una relazione positiva, abbastanza lineare e relativamente 
#|   forte tra queste due variabili. Le specie (Adelie, 
#|   Chinstrap, e Gentoo) sono rappresentate con colori e 
#|   forme diverse. La relazione tra massa corporea e lunghezza delle pinne è 
#|   approssimativamente la stessa per queste tre specie, e i pinguini Gentoo sono 
#|   più grandi dei pinguini delle altre due specie.
ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point(aes(color = species, shape = species)) +
  geom_smooth(method = "lm") +
  labs(
    title = "Massa corporea e lunghezza delle pinne",
    subtitle = "Dimensioni per pinguini Adelie, Chinstrap, e Gentoo",
    x = "Lunghezza pinne (mm)",
    y = "Massa corporea (g)",
    color = "Specie",
    shape = "Specie"
  ) +
  scale_color_colorblind()
```

### Creare un ggplot

Ricreiamo questo grafico passo dopo passo.

Con ggplot2, inizi un grafico con la funzione `ggplot()`, definendo un oggetto grafico al quale poi aggiungi **layer**.
Il primo argomento di `ggplot()` è il dataset da usare nel grafico e quindi `ggplot(data = penguins)` crea un grafico vuoto che è pronto a mostrare i dati `penguins`, ma dato che non gli abbiamo ancora detto come visualizzarli, per ora è vuoto.
Questo non è un grafico molto entusiasmante, ma puoi pensarlo come una tela vuota su cui dipingerai i layer rimanenti del tuo grafico.

```{r}
#| fig-alt: |
#|   Un'area di grafico vuota e grigia.
ggplot(data = penguins)
```

Successivamente, dobbiamo dire a `ggplot()` come le informazioni dai nostri dati saranno rappresentate visivamente.
L'argomento `mapping` della funzione `ggplot()` definisce come le variabili nel tuo dataset sono mappate alle proprietà visive (**estetiche**) del tuo grafico.
L'argomento `mapping` è sempre definito nella funzione `aes()`, e gli argomenti `x` e `y` di `aes()` specificano quali variabili mappare agli assi x e y.
Per ora, mapperemo solo la lunghezza delle pinne all'estetica `x` e la massa corporea all'estetica `y`.
ggplot2 cerca le variabili mappate nell'argomento `data`, in questo caso, `penguins`.

Il seguente grafico mostra il risultato dell'aggiunta di queste mappature.

```{r}
#| fig-alt: |
#|   Il grafico mostra la lunghezza delle pinne sull'asse x, con valori che vanno da 
#|   170 a 230, e la massa corporea sull'asse y, con valori che vanno da 3000 
#|   a 6000.
ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
)
```

La nostra tela vuota ora ha più struttura -- è chiaro dove saranno mostrate le lunghezze delle pinne (sull'asse x) e dove saranno mostrate le masse corporee (sull'asse y).
Ma i pinguini stessi non sono ancora sul grafico.
Questo perché non abbiamo ancora articolato, nel nostro codice, come rappresentare le osservazioni dal nostro data frame sul nostro grafico.

Per farlo, dobbiamo definire un **geom**: l'oggetto geometrico che un grafico usa per rappresentare i dati.
Questi oggetti geometrici sono resi disponibili in ggplot2 con funzioni che iniziano con `geom_`.
Le persone spesso descrivono i grafici per il tipo di geom che il grafico usa.
Per esempio, i grafici a barre usano bar geom (`geom_bar()`), i grafici a linee usano line geom (`geom_line()`), i boxplot usano boxplot geom (`geom_boxplot()`), i grafici a dispersione usano point geom (`geom_point()`), e così via.

La funzione `geom_point()` aggiunge un layer di punti al tuo grafico, che crea un grafico a dispersione.
ggplot2 viene con molte funzioni geom che ognuna aggiunge un tipo diverso di layer a un grafico.
Imparerai un sacco di geom in tutto il libro, particolarmente in @sec-layers.

```{r}
#| fig-alt: |
#|   Un grafico a dispersione di massa corporea vs. lunghezza delle pinne di pinguini. Il grafico 
#|   mostra una relazione positiva, lineare e relativamente forte tra 
#|   queste due variabili.
ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
  geom_point()
```

Ora abbiamo qualcosa che assomiglia a quello che potremmo pensare come un "grafico a dispersione".
Non corrisponde ancora al nostro grafico "obiettivo finale", ma usando questo grafico possiamo iniziare a rispondere alla domanda che ha motivato la nostra esplorazione: "Come appare la relazione tra lunghezza delle pinne e massa corporea?" La relazione sembra essere positiva (man mano che la lunghezza delle pinne aumenta, aumenta anche la massa corporea), abbastanza lineare (i punti sono raggruppati intorno a una linea invece che a una curva), e moderatamente forte (non c'è troppa dispersione intorno a tale linea).
I pinguini con pinne più lunghe sono generalmente più grandi in termini di massa corporea.

Prima di aggiungere più layer a questo grafico, facciamo una pausa per un momento e rivediamo il messaggio di avvertimento che abbiamo ricevuto:

> Removed 2 rows containing missing values (`geom_point()`).

Stiamo vedendo questo messaggio perché ci sono due pinguini nel nostro dataset con valori mancanti di massa corporea e/o lunghezza delle pinne e ggplot2 non ha modo di rappresentarli sul grafico senza entrambi questi valori.
Come R, ggplot2 aderisce alla filosofia che i valori mancanti non dovrebbero mai sparire silenziosamente.
Questo tipo di avvertimento è probabilmente uno dei tipi più comuni di avvertimenti che vedrai quando lavori con dati reali -- i valori mancanti sono un problema molto comune e imparerai di più su di essi in tutto il libro, particolarmente in @sec-missing-values.
Per i grafici rimanenti in questo capitolo sopprimeremo questo avvertimento così non viene stampato insieme a ogni singolo grafico che facciamo.

### Aggiungere estetiche e layer {#sec-adding-aesthetics-layers}

I grafici a dispersione sono utili per mostrare la relazione tra due variabili numeriche, ma è sempre una buona idea essere scettici di qualsiasi relazione apparente tra due variabili e chiedersi se possano esserci altre variabili che spiegano o cambiano la natura di questa relazione apparente.
Per esempio, la relazione tra lunghezza delle pinne e massa corporea differisce per specie?
Incorporiamo la specie nel nostro grafico e vediamo se questo rivela intuizioni aggiuntive nella relazione apparente tra queste variabili.
Faremo questo rappresentando le specie con punti di colori diversi.

Per raggiungere questo, avremo bisogno di modificare l'estetica o il geom?
Se hai indovinato "nella mappatura estetica, dentro `aes()`", stai già prendendo la mano nel creare visualizzazioni di dati con ggplot2!
E se non l'hai fatto, non preoccuparti.
In tutto il libro farai molti più ggplot e avrai molte più opportunità di controllare la tua intuizione mentre li fai.

```{r}
#| warning: false
#| fig-alt: |
#|   Un grafico a dispersione di massa corporea vs. lunghezza delle pinne di pinguini. Il grafico 
#|   mostra una relazione positiva, abbastanza lineare e relativamente forte 
#|   tra queste due variabili. Le specie (Adelie, Chinstrap, e Gentoo) 
#|   sono rappresentate con colori diversi.
ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)
) +
  geom_point()
```

Quando una variabile categorica è mappata a un'estetica, ggplot2 assegnerà automaticamente un valore unico dell'estetica (qui un colore unico) a ogni livello unico della variabile (ognuna delle tre specie), un processo noto come **scaling**.
ggplot2 aggiungerà anche una legenda che spiega quali valori corrispondono a quali livelli.

Ora aggiungiamo un altro layer: una curva liscia che mostra la relazione tra massa corporea e lunghezza delle pinne.
Prima di procedere, torna al codice sopra, e pensa a come possiamo aggiungere questo al nostro grafico esistente.

Dato che questo è un nuovo oggetto geometrico che rappresenta i nostri dati, aggiungeremo un nuovo geom come layer sopra il nostro point geom: `geom_smooth()`.
E specificheremo che vogliamo disegnare la linea di migliore adattamento basata su un `m`odello `l`ineare con `method = "lm"`.

```{r}
#| warning: false
#| fig-alt: |
#|   Un grafico a dispersione di massa corporea vs. lunghezza delle pinne di pinguini. Sovrapposte 
#|   al grafico a dispersione ci sono tre curve lisce che mostrano la 
#|   relazione tra queste variabili per ogni specie (Adelie, 
#|   Chinstrap, e Gentoo). Specie diverse di pinguini sono graficate in 
#|   colori diversi per i punti e le curve lisce.
ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g, color = species)
) +
  geom_point() +
  geom_smooth(method = "lm")
```

Abbiamo aggiunto con successo le linee, ma questo grafico non assomiglia al grafico di @sec-ultimate-goal, che ha solo una linea per l'intero dataset invece di linee separate per ogni specie di pinguini.

Quando le mappature estetiche sono definite in `ggplot()`, a livello *globale*, vengono passate a ognuno dei layer geom successivi del grafico.
Tuttavia, ogni funzione geom in ggplot2 può anche prendere un argomento `mapping`, che permette mappature estetiche a livello *locale* che si aggiungono a quelle ereditate dal livello globale.
Dato che vogliamo che i punti siano colorati basandosi sulla specie ma non vogliamo che le linee siano separate per loro, dovremmo specificare `color = species` solo per `geom_point()`.

```{r}
#| warning: false
#| fig-alt: |
#|   Un grafico a dispersione di massa corporea vs. lunghezza delle pinne di pinguini. Sovrapposta 
#|   al grafico a dispersione c'è una singola linea di migliore adattamento che mostra la 
#|   relazione tra queste variabili per ogni specie (Adelie, 
#|   Chinstrap, e Gentoo). Specie diverse di pinguini sono graficate in 
#|   colori diversi solo per i punti.
ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
  geom_point(mapping = aes(color = species)) +
  geom_smooth(method = "lm")
```

Voilà!
Abbiamo qualcosa che assomiglia molto al nostro obiettivo finale, anche se non è ancora perfetto.
Dobbiamo ancora usare forme diverse per ogni specie di pinguini e migliorare le etichette.

Generalmente non è una buona idea rappresentare informazioni usando solo i colori in un grafico, dato che le persone percepiscono i colori diversamente a causa del daltonismo o altre differenze di visione dei colori.
Quindi, oltre al colore, possiamo anche mappare `species` all'estetica `shape`.

```{r}
#| warning: false
#| fig-alt: |
#|   Un grafico a dispersione di massa corporea vs. lunghezza delle pinne di pinguini. Sovrapposta 
#|   al grafico a dispersione c'è una singola linea di migliore adattamento che mostra la 
#|   relazione tra queste variabili per ogni specie (Adelie, 
#|   Chinstrap, e Gentoo). Specie diverse di pinguini sono graficate in 
#|   colori e forme diverse solo per i punti.
ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
  geom_point(mapping = aes(color = species, shape = species)) +
  geom_smooth(method = "lm")
```

Nota che la legenda è automaticamente aggiornata per riflettere anche le diverse forme dei punti.

E infine, possiamo migliorare le etichette del nostro grafico usando la funzione `labs()` in un nuovo layer.
Alcuni degli argomenti di `labs()` potrebbero essere auto-esplicativi: `title` aggiunge un titolo e `subtitle` aggiunge un sottotitolo al grafico.
Altri argomenti corrispondono alle mappature estetiche, `x` è l'etichetta dell'asse x, `y` è l'etichetta dell'asse y, e `color` e `shape` definiscono l'etichetta per la legenda.
Inoltre, possiamo migliorare la palette di colori per essere sicura per i daltonici con la funzione `scale_color_colorblind()` del pacchetto ggthemes.

```{r}
#| warning: false
#| fig-alt: |
#|   A scatterplot of body mass vs. flipper length of penguins, with a 
#|   line of best fit displaying the relationship between these two variables 
#|   overlaid. The plot displays a positive, fairly linear, and relatively 
#|   strong relationship between these two variables. Species (Adelie, 
#|   Chinstrap, and Gentoo) are represented with different colors and 
#|   shapes. The relationship between body mass and flipper length is 
#|   roughly the same for these three species, and Gentoo penguins are 
#|   larger than penguins from the other two species.
ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
  geom_point(aes(color = species, shape = species)) +
  geom_smooth(method = "lm") +
  labs(
    title = "Massa corporea e lunghezza delle pinne",
    subtitle = "Dimensioni per pinguini Adelie, Chinstrap, e Gentoo",
    x = "Lunghezza pinne (mm)", y = "Massa corporea (g)",
    color = "Specie", shape = "Specie"
  ) +
  scale_color_colorblind()
```

Finalmente abbiamo un grafico che corrisponde perfettamente al nostro "obiettivo finale"!

### Esercizi

1.  Quante righe ci sono in `penguins`?
    Quante colonne?

2.  Cosa descrive la variabile `bill_depth_mm` nel data frame `penguins`?
    Leggi l'aiuto per `?penguins` per scoprirlo.

3.  Crea un grafico a dispersione di `bill_depth_mm` vs. `bill_length_mm`.
    Cioè, crea un grafico a dispersione con `bill_depth_mm` sull'asse y e `bill_length_mm` sull'asse x.
    Descrivi la relazione tra queste due variabili.

4.  Cosa succede se crei un grafico a dispersione di `species` vs. `bill_depth_mm`?
    Quale potrebbe essere una scelta migliore di geom?

5.  Perché il seguente codice dà un errore e come lo risolveresti?

    ```{r}
    #| eval: false
    ggplot(data = penguins) + 
      geom_point()
    ```

6.  Cosa fa l'argomento `na.rm` in `geom_point()`?
    Qual è il valore predefinito dell'argomento?
    Crea un grafico a dispersione dove usi con successo questo argomento impostato a `TRUE`.

7.  Aggiungi la seguente didascalia al grafico che hai fatto nell'esercizio precedente: "I dati provengono dal pacchetto palmerpenguins." Suggerimento: Dai un'occhiata alla documentazione per `labs()`.

8.  Ricrea la seguente visualizzazione.
    A quale estetica dovrebbe essere mappata `bill_depth_mm`?
    E dovrebbe essere mappata a livello globale o a livello geom?

    ```{r}
    #| echo: false
    #| warning: false
    #| fig-alt: |
    #|   A scatterplot of body mass vs. flipper length of penguins, colored 
    #|   by bill depth. A smooth curve of the relationship between body mass 
    #|   and flipper length is overlaid. The relationship is positive, 
    #|   fairly linear, and moderately strong.
    ggplot(
      data = penguins,
      mapping = aes(x = flipper_length_mm, y = body_mass_g)
    ) +
      geom_point(aes(color = bill_depth_mm)) +
      geom_smooth()
    ```

9.  Run this code in your head and predict what the output will look like.
    Then, run the code in R and check your predictions.

    ```{r}
    #| eval: false
    ggplot(
      data = penguins,
      mapping = aes(x = flipper_length_mm, y = body_mass_g, color = island)
    ) +
      geom_point() +
      geom_smooth(se = FALSE)
    ```

10. Will these two graphs look different?
    Why/why not?

    ```{r}
    #| eval: false
    ggplot(
      data = penguins,
      mapping = aes(x = flipper_length_mm, y = body_mass_g)
    ) +
      geom_point() +
      geom_smooth()

    ggplot() +
      geom_point(
        data = penguins,
        mapping = aes(x = flipper_length_mm, y = body_mass_g)
      ) +
      geom_smooth(
        data = penguins,
        mapping = aes(x = flipper_length_mm, y = body_mass_g)
      )
    ```

## Chiamate ggplot2 {#sec-ggplot2-calls}

Mentre passiamo da queste sezioni introduttive, faremo una transizione a un'espressione più concisa del codice ggplot2.
Finora siamo stati molto espliciti, il che è utile quando stai imparando:

```{r}
#| eval: false
ggplot(
  data = penguins,
  mapping = aes(x = flipper_length_mm, y = body_mass_g)
) +
  geom_point()
```

Tipicamente, i primi uno o due argomenti di una funzione sono così importanti che dovresti conoscerli a memoria.
I primi due argomenti di `ggplot()` sono `data` e `mapping`, nel resto del libro, non forniremo quei nomi.
Questo fa risparmiare digitazione, e, riducendo la quantità di testo extra, rende più facile vedere cosa è diverso tra i grafici.
Questa è una preoccupazione di programmazione davvero importante su cui torneremo in @sec-functions.

Riscrivere il grafico precedente più concisamente produce:

```{r}
#| eval: false
ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) + 
  geom_point()
```

In futuro, imparerai anche sulla pipe, `|>`, che ti permetterà di creare quel grafico con:

```{r}
#| eval: false
penguins |> 
  ggplot(aes(x = flipper_length_mm, y = body_mass_g)) + 
  geom_point()
```

## Visualizzare le distribuzioni

Come visualizzi la distribuzione di una variabile dipende dal tipo di variabile: categorica o numerica.

### Una variabile categorica

Una variabile è **categorica** se può assumere solo uno di un piccolo insieme di valori.
Per esaminare la distribuzione di una variabile categorica, puoi usare un grafico a barre.
L'altezza delle barre mostra quante osservazioni si sono verificate con ogni valore `x`.

```{r}
#| fig-alt: |
#|   A bar chart of frequencies of species of penguins: Adelie 
#|   (approximately 150), Chinstrap (approximately 90), Gentoo 
#|   (approximately 125).
ggplot(penguins, aes(x = species)) +
  geom_bar()
```

In bar plots of categorical variables with non-ordered levels, like the penguin `species` above, it's often preferable to reorder the bars based on their frequencies.
Doing so requires transforming the variable to a factor (how R handles categorical data) and then reordering the levels of that factor.

```{r}
#| fig-alt: |
#|   A bar chart of frequencies of species of penguins, where the bars are 
#|   ordered in decreasing order of their heights (frequencies): Adelie 
#|   (approximately 150), Gentoo (approximately 125), Chinstrap 
#|   (approximately 90).
ggplot(penguins, aes(x = fct_infreq(species))) +
  geom_bar()
```

You will learn more about factors and functions for dealing with factors (like `fct_infreq()` shown above) in @sec-factors.

### Una variabile numerica

Una variabile è **numerica** (o quantitativa) se può assumere un'ampia gamma di valori numerici, ed è sensato aggiungere, sottrarre, o prendere medie con quei valori.
Le variabili numeriche possono essere continue o discrete.

Una visualizzazione comunemente usata per le distribuzioni di variabili continue è un istogramma.

```{r}
#| warning: false
#| fig-alt: |
#|   Un istogramma delle masse corporee di pinguini. La distribuzione è unimodale 
#|   e asimmetrica a destra, varia tra circa 2500 e 6500 grammi.
ggplot(penguins, aes(x = body_mass_g)) +
  geom_histogram(binwidth = 200)
```

Un istogramma divide l'asse x in bin equidistanziati e poi usa l'altezza di una barra per mostrare il numero di osservazioni che cadono in ogni bin.
Nel grafico sopra, la barra più alta mostra che 39 osservazioni hanno un valore `body_mass_g` tra 3.500 e 3.700 grammi, che sono i bordi sinistro e destro della barra.

Puoi impostare la larghezza degli intervalli in un istogramma con l'argomento binwidth, che è misurato nelle unità della variabile `x`.
Dovresti sempre esplorare una varietà di binwidth quando lavori con istogrammi, poiché binwidth diversi possono rivelare pattern diversi.
Nei grafici sotto un binwidth di 20 è troppo stretto, risultando in troppe barre, rendendo difficile determinare la forma della distribuzione.
Similmente, un binwidth di 2.000 è troppo alto, risultando in tutti i dati raggruppati in solo tre barre, e rendendo anche difficile determinare la forma della distribuzione.
Un binwidth di 200 fornisce un equilibrio sensato.

```{r}
#| warning: false
#| layout-ncol: 2
#| fig-width: 3
#| fig-alt: |
#|   Due istogrammi delle masse corporee di pinguini, uno con binwidth di 20 
#|   (sinistra) e uno con binwidth di 2000 (destra). L'istogramma con binwidth 
#|   di 20 mostra molti alti e bassi nelle altezze dei bin, creando un 
#|   contorno frastagliato. L'istogramma con binwidth di 2000 mostra solo tre bin.
ggplot(penguins, aes(x = body_mass_g)) +
  geom_histogram(binwidth = 20)
ggplot(penguins, aes(x = body_mass_g)) +
  geom_histogram(binwidth = 2000)
```

Una visualizzazione alternativa per le distribuzioni di variabili numeriche è un grafico di densità.
Un grafico di densità è una versione levigata di un istogramma e un'alternativa pratica, particolarmente per dati continui che provengono da una distribuzione liscia sottostante.
Non approfondiremo come `geom_density()` stima la densità (puoi leggere di più su questo nella documentazione della funzione), ma spieghiamo come la curva di densità viene disegnata con un'analogia.
Immagina un istogramma fatto di blocchi di legno.
Poi, immagina di far cadere uno spaghetto cotto sopra di esso.
La forma che gli spaghetti prenderanno drappeggiati sui blocchi può essere pensata come la forma della curva di densità.
Mostra meno dettagli di un istogramma ma può rendere più facile cogliere rapidamente la forma della distribuzione, particolarmente rispetto a modi e asimmetria.

```{r}
#| fig-alt: |
#|   A density plot of body masses of penguins. The distribution is unimodal 
#|   and right skewed, ranging between approximately 2500 to 6500 grams.
ggplot(penguins, aes(x = body_mass_g)) +
  geom_density()
```

### Exercises

1.  Make a bar plot of `species` of `penguins`, where you assign `species` to the `y` aesthetic.
    How is this plot different?

2.  How are the following two plots different?
    Which aesthetic, `color` or `fill`, is more useful for changing the color of bars?

    ```{r}
    #| eval: false
    ggplot(penguins, aes(x = species)) +
      geom_bar(color = "red")

    ggplot(penguins, aes(x = species)) +
      geom_bar(fill = "red")
    ```

3.  What does the `bins` argument in `geom_histogram()` do?

4.  Make a histogram of the `carat` variable in the `diamonds` dataset that is available when you load the tidyverse package.
    Experiment with different binwidths.
    What binwidth reveals the most interesting patterns?

## Visualizing relationships

To visualize a relationship we need to have at least two variables mapped to aesthetics of a plot.
In the following sections you will learn about commonly used plots for visualizing relationships between two or more variables and the geoms used for creating them.

### A numerical and a categorical variable

To visualize the relationship between a numerical and a categorical variable we can use side-by-side box plots.
A **boxplot** is a type of visual shorthand for measures of position (percentiles) that describe a distribution.
It is also useful for identifying potential outliers.
As shown in @fig-eda-boxplot, each boxplot consists of:

-   A box that indicates the range of the middle half of the data, a distance known as the interquartile range (IQR), stretching from the 25th percentile of the distribution to the 75th percentile.
    In the middle of the box is a line that displays the median, i.e. 50th percentile, of the distribution.
    These three lines give you a sense of the spread of the distribution and whether or not the distribution is symmetric about the median or skewed to one side.

-   Visual points that display observations that fall more than 1.5 times the IQR from either edge of the box.
    These outlying points are unusual so are plotted individually.

-   A line (or whisker) that extends from each end of the box and goes to the farthest non-outlier point in the distribution.

```{r}
#| label: fig-eda-boxplot
#| echo: false
#| fig-cap: |
#|   Diagram depicting how a boxplot is created.
#| fig-alt: |
#|   A diagram depicting how a boxplot is created following the steps outlined 
#|   above.
knitr::include_graphics("images/EDA-boxplot.png")
```

Let's take a look at the distribution of body mass by species using `geom_boxplot()`:

```{r}
#| warning: false
#| fig-alt: |
#|   Side-by-side box plots of distributions of body masses of Adelie, 
#|   Chinstrap, and Gentoo penguins. The distribution of Adelie and 
#|   Chinstrap penguins' body masses appear to be symmetric with 
#|   medians around 3750 grams. The median body mass of Gentoo penguins 
#|   is much higher, around 5000 grams, and the distribution of the 
#|   body masses of these penguins appears to be somewhat right skewed.
ggplot(penguins, aes(x = species, y = body_mass_g)) +
  geom_boxplot()
```

Alternatively, we can make density plots with `geom_density()`.

```{r}
#| warning: false
#| fig-alt: |
#|   A density plot of body masses of penguins by species of penguins. Each 
#|   species (Adelie, Chinstrap, and Gentoo) is represented with different 
#|   colored outlines for the density curves.
ggplot(penguins, aes(x = body_mass_g, color = species)) +
  geom_density(linewidth = 0.75)
```

We've also customized the thickness of the lines using the `linewidth` argument in order to make them stand out a bit more against the background.

Additionally, we can map `species` to both `color` and `fill` aesthetics and use the `alpha` aesthetic to add transparency to the filled density curves.
This aesthetic takes values between 0 (completely transparent) and 1 (completely opaque).
In the following plot it's *set* to 0.5.

```{r}
#| warning: false
#| fig-alt: |
#|   A density plot of body masses of penguins by species of penguins. Each 
#|   species (Adelie, Chinstrap, and Gentoo) is represented in different 
#|   colored outlines for the density curves. The density curves are also 
#|   filled with the same colors, with some transparency added.
ggplot(penguins, aes(x = body_mass_g, color = species, fill = species)) +
  geom_density(alpha = 0.5)
```

Note the terminology we have used here:

-   We *map* variables to aesthetics if we want the visual attribute represented by that aesthetic to vary based on the values of that variable.
-   Otherwise, we *set* the value of an aesthetic.

### Two categorical variables

We can use stacked bar plots to visualize the relationship between two categorical variables.
For example, the following two stacked bar plots both display the relationship between `island` and `species`, or specifically, visualizing the distribution of `species` within each island.

The first plot shows the frequencies of each species of penguins on each island.
The plot of frequencies shows that there are equal numbers of Adelies on each island.
But we don't have a good sense of the percentage balance within each island.

```{r}
#| fig-alt: |
#|   Bar plots of penguin species by island (Biscoe, Dream, and Torgersen)
ggplot(penguins, aes(x = island, fill = species)) +
  geom_bar()
```

The second plot, a relative frequency plot created by setting `position = "fill"` in the geom, is more useful for comparing species distributions across islands since it's not affected by the unequal numbers of penguins across the islands.
Using this plot we can see that Gentoo penguins all live on Biscoe island and make up roughly 75% of the penguins on that island, Chinstrap all live on Dream island and make up roughly 50% of the penguins on that island, and Adelie live on all three islands and make up all of the penguins on Torgersen.

```{r}
#| fig-alt: |
#|   Bar plots of penguin species by island (Biscoe, Dream, and Torgersen)
#|   the bars are scaled to the same height, making it a relative frequencies 
#|   plot
ggplot(penguins, aes(x = island, fill = species)) +
  geom_bar(position = "fill")
```

In creating these bar charts, we map the variable that will be separated into bars to the `x` aesthetic, and the variable that will change the colors inside the bars to the `fill` aesthetic.

### Two numerical variables

So far you've learned about scatterplots (created with `geom_point()`) and smooth curves (created with `geom_smooth()`) for visualizing the relationship between two numerical variables.
A scatterplot is probably the most commonly used plot for visualizing the relationship between two numerical variables.

```{r}
#| warning: false
#| fig-alt: |
#|   A scatterplot of body mass vs. flipper length of penguins. The plot 
#|   displays a positive, linear, relatively strong relationship between 
#|   these two variables.
ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point()
```

### Three or more variables

As we saw in @sec-adding-aesthetics-layers, we can incorporate more variables into a plot by mapping them to additional aesthetics.
For example, in the following scatterplot the colors of points represent species and the shapes of points represent islands.

```{r}
#| warning: false
#| fig-alt: |
#|   A scatterplot of body mass vs. flipper length of penguins. The plot 
#|   displays a positive, linear, relatively strong relationship between 
#|   these two variables. The points are colored based on the species of the 
#|   penguins and the shapes of the points represent islands (round points are 
#|   Biscoe island, triangles are Dream island, and squared are Torgersen 
#|   island). The plot is very busy and it's difficult to distinguish the shapes
#|   of the points.
ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point(aes(color = species, shape = island))
```

However adding too many aesthetic mappings to a plot makes it cluttered and difficult to make sense of.
Another way, which is particularly useful for categorical variables, is to split your plot into **facets**, subplots that each display one subset of the data.

To facet your plot by a single variable, use `facet_wrap()`.
The first argument of `facet_wrap()` is a formula[^data-visualize-3], which you create with `~` followed by a variable name.
The variable that you pass to `facet_wrap()` should be categorical.

[^data-visualize-3]: Here "formula" is the name of the thing created by `~`, not a synonym for "equation".

```{r}
#| warning: false
#| fig-width: 8
#| fig-asp: 0.33
#| fig-alt: |
#|   A scatterplot of body mass vs. flipper length of penguins. The shapes and 
#|   colors of points represent species. Penguins from each island are on a 
#|   separate facet. Within each facet, the relationship between body mass and 
#|   flipper length is positive, linear, relatively strong. 
ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point(aes(color = species, shape = species)) +
  facet_wrap(~island)
```

You will learn about many other geoms for visualizing distributions of variables and relationships between them in @sec-layers.

### Exercises

1.  The `mpg` data frame that is bundled with the ggplot2 package contains `r nrow(mpg)` observations collected by the US Environmental Protection Agency on `r mpg |> distinct(model) |> nrow()` car models.
    Which variables in `mpg` are categorical?
    Which variables are numerical?
    (Hint: Type `?mpg` to read the documentation for the dataset.) How can you see this information when you run `mpg`?

2.  Make a scatterplot of `hwy` vs. `displ` using the `mpg` data frame.
    Next, map a third, numerical variable to `color`, then `size`, then both `color` and `size`, then `shape`.
    How do these aesthetics behave differently for categorical vs. numerical variables?

3.  In the scatterplot of `hwy` vs. `displ`, what happens if you map a third variable to `linewidth`?

4.  What happens if you map the same variable to multiple aesthetics?

5.  Make a scatterplot of `bill_depth_mm` vs. `bill_length_mm` and color the points by `species`.
    What does adding coloring by species reveal about the relationship between these two variables?
    What about faceting by `species`?

6.  Why does the following yield two separate legends?
    How would you fix it to combine the two legends?

    ```{r}
    #| warning: false
    #| fig-show: hide
    ggplot(
      data = penguins,
      mapping = aes(
        x = bill_length_mm, y = bill_depth_mm, 
        color = species, shape = species
      )
    ) +
      geom_point() +
      labs(color = "Species")
    ```

7.  Create the two following stacked bar plots.
    Which question can you answer with the first one?
    Which question can you answer with the second one?

    ```{r}
    #| fig-show: hide
    ggplot(penguins, aes(x = island, fill = species)) +
      geom_bar(position = "fill")
    ggplot(penguins, aes(x = species, fill = island)) +
      geom_bar(position = "fill")
    ```

## Salvare i tuoi grafici {#sec-ggsave}

Una volta che hai creato un grafico, potresti volerlo portare fuori da R salvandolo come immagine che puoi usare altrove.
Questo è il compito di `ggsave()`, che salverà il grafico creato più di recente su disco:

```{r}
#| fig-show: hide
#| warning: false
ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point()
ggsave(filename = "penguin-plot.png")
```

```{r}
#| include: false
file.remove("penguin-plot.png")
```

Questo salverà il tuo grafico nella tua directory di lavoro, un concetto su cui imparerai di più in @sec-workflow-scripts-projects.

Se non specifichi `width` e `height` saranno presi dalle dimensioni del dispositivo di grafico corrente.
Per codice riproducibile, vorrai specificarli.
Puoi imparare di più su `ggsave()` nella documentazione.

Generalmente, tuttavia, raccomandiamo che tu assembli i tuoi report finali usando Quarto, un sistema di authoring riproducibile che ti permette di intrecciare il tuo codice e la tua prosa e includere automaticamente i tuoi grafici nei tuoi scritti.
Imparerai di più su Quarto in @sec-quarto.

### Esercizi

1.  Esegui le seguenti righe di codice.
    Quale dei due grafici viene salvato come `mpg-plot.png`?
    Perché?

    ```{r}
    #| eval: false
    ggplot(mpg, aes(x = class)) +
      geom_bar()
    ggplot(mpg, aes(x = cty, y = hwy)) +
      geom_point()
    ggsave("mpg-plot.png")
    ```

2.  Cosa devi cambiare nel codice sopra per salvare il grafico come PDF invece che PNG?
    Come potresti scoprire quali tipi di file immagine funzionerebbero in `ggsave()`?

## Problemi comuni

Mentre inizi a eseguire codice R, è probabile che incontrerai problemi.
Non preoccuparti --- succede a tutti.
Tutti noi abbiamo scritto codice R per anni, ma ogni giorno scriviamo ancora codice che non funziona al primo tentativo!

Start by carefully comparing the code that you're running to the code in the book.
R is extremely picky, and a misplaced character can make all the difference.
Make sure that every `(` is matched with a `)` and every `"` is paired with another `"`.
Sometimes you'll run the code and nothing happens.
Check the left-hand of your console: if it's a `+`, it means that R doesn't think you've typed a complete expression and it's waiting for you to finish it.
In this case, it's usually easy to start from scratch again by pressing ESCAPE to abort processing the current command.

One common problem when creating ggplot2 graphics is to put the `+` in the wrong place: it has to come at the end of the line, not the start.
In other words, make sure you haven't accidentally written code like this:

```{r}
#| eval: false
ggplot(data = mpg) 
+ geom_point(mapping = aes(x = displ, y = hwy))
```

If you're still stuck, try the help.
You can get help about any R function by running `?function_name` in the console, or highlighting the function name and pressing F1 in RStudio.
Don't worry if the help doesn't seem that helpful - instead skip down to the examples and look for code that matches what you're trying to do.

If that doesn't help, carefully read the error message.
Sometimes the answer will be buried there!
But when you're new to R, even if the answer is in the error message, you might not yet know how to understand it.
Another great tool is Google: try googling the error message, as it's likely someone else has had the same problem, and has gotten help online.

## Riassunto

In questo capitolo, hai imparato le basi della visualizzazione dei dati con ggplot2.
Abbiamo iniziato con l'idea di base che sostiene ggplot2: una visualizzazione è una mappatura dalle variabili nei tuoi dati alle proprietà estetiche come posizione, colore, dimensione e forma.
Poi hai imparato ad aumentare la complessità e migliorare la presentazione dei tuoi grafici layer per layer.
Hai anche imparato sui grafici comunemente usati per visualizzare la distribuzione di una singola variabile così come per visualizzare relazioni tra due o più variabili, sfruttando mappature estetiche aggiuntive e/o dividendo il tuo grafico in piccoli multipli usando il faceting.

Useremo visualizzazioni ancora e ancora in tutto questo libro, introducendo nuove tecniche man mano che ne abbiamo bisogno così come facendo un approfondimento nella creazione di visualizzazioni con ggplot2 da @sec-layers a @sec-communication.

Con le basi della visualizzazione nella tua cintura degli attrezzi, nel prossimo capitolo cambieremo un po' marcia e ti daremo alcuni consigli pratici di workflow.
Intercaliamo consigli di workflow con strumenti di data science in tutta questa parte del libro perché ti aiuterà a rimanere organizzato mentre scrivi quantità crescenti di codice R.