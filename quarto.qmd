# Quarto {#sec-quarto}

```{r}
#| echo: false
source("_common.R")
```

## Introduzione

Quarto fornisce un framework di authoring unificato per la data science, combinando il vostro codice, i suoi risultati e la vostra prosa.
I documenti Quarto sono completamente riproducibili e supportano dozzine di formati di output, come PDF, file Word, presentazioni e altro.

I file Quarto sono progettati per essere usati in tre modi:

1.  Per comunicare ai decisori, che vogliono concentrarsi sulle conclusioni, non sul codice dietro l'analisi.

2.  Per collaborare con altri data scientist (incluso il voi del futuro!), che sono interessati sia alle vostre conclusioni, sia a come ci siete arrivati (cioè il codice).

3.  Come ambiente in cui *fare* data science, come un quaderno di laboratorio moderno dove potete catturare non solo quello che avete fatto, ma anche quello che stavate pensando.

Quarto è uno strumento da riga di comando, non un pacchetto R.
Questo significa che l'aiuto, in generale, non è disponibile tramite `?`.
Invece, mentre lavorate attraverso questo capitolo e usate Quarto in futuro, dovreste fare riferimento alla [documentazione Quarto](https://quarto.org).

Se siete utenti di R Markdown, potreste pensare "Quarto suona molto come R Markdown".
Non sbagliate!
Quarto unifica la funzionalità di molti pacchetti dall'ecosistema R Markdown (rmarkdown, bookdown, distill, xaringan, ecc.) in un singolo sistema coerente e lo estende anche con supporto nativo per più linguaggi di programmazione come Python e Julia oltre a R.
In un certo senso, Quarto riflette tutto quello che è stato imparato dall'espansione e supporto dell'ecosistema R Markdown in un decennio.

### Prerequisiti

Avete bisogno dell'interfaccia a riga di comando Quarto (Quarto CLI), ma non dovete installarla o caricarla esplicitamente, poiché RStudio fa automaticamente entrambe le cose quando necessario.

```{r}
#| label: setup
#| include: false
chunk <- "```"
inline <- function(x = "") paste0("`` `r ", x, "` ``")
library(tidyverse)
```

## Basi di Quarto

Questo è un file Quarto -- un file di testo semplice che ha l'estensione `.qmd`:

```{r echo = FALSE, comment = ""}
cat(readr::read_file("quarto/diamond-sizes.qmd"))
```

Contiene tre tipi importanti di contenuto:

1.  Un **header YAML** (opzionale) circondato da `---`.
2.  **Chunk** di codice R circondati da ```` ``` ````.
3.  Testo mescolato con formattazione semplice del testo come `# heading` e `_italics_`.

@fig-diamond-sizes-notebook mostra un documento `.qmd` in RStudio con interfaccia notebook dove codice e output sono intercalati.
Potete eseguire ogni chunk di codice cliccando sull'icona Run (sembra un bottone play in cima al chunk), o premendo Cmd/Ctrl + Shift + Enter.
RStudio esegue il codice e mostra i risultati inline con il codice.

```{r}
#| label: fig-diamond-sizes-notebook
#| echo: false
#| out-width: "90%"
#| fig-cap: |
#|   Un documento Quarto in RStudio. Codice e output intercalati nel 
#|   documento, con l'output del grafico che appare proprio sotto il codice.
#| fig-alt: |
#|   Finestra RStudio con un documento Quarto intitolato "diamond-sizes.qmd" 
#|   a sinistra e una finestra Viewer vuota a destra. Il documento Quarto 
#|   ha un chunk di codice che crea un grafico di frequenza dei diamanti 
#|   che pesano meno di 2.5 carati. Il grafico mostra che la frequenza 
#|   diminuisce all'aumentare del peso.
knitr::include_graphics("quarto/diamond-sizes-notebook.png")
```

Se non vi piace vedere i vostri grafici e output nel vostro documento e preferite usare i pannelli Console e Plot di RStudio, potete cliccare sull'icona ingranaggio accanto a "Render" e passare a "Chunk Output in Console", come mostrato in @fig-diamond-sizes-console-output.

```{r}
#| label: fig-diamond-sizes-console-output
#| echo: false
#| out-width: "90%"
#| fig-cap: |
#|   Un documento Quarto in RStudio con l'output del grafico nel pannello Plots.
#| fig-alt: |
#|   Finestra RStudio con un documento Quarto intitolato "diamond-sizes.qmd" 
#|   a sinistra e il pannello Plot in basso a destra. Il documento Quarto 
#|   ha un chunk di codice che crea un grafico di frequenza dei diamanti 
#|   che pesano meno di 2.5 carati. Il grafico è mostrato nel pannello 
#|   Plot e mostra che la frequenza diminuisce all'aumentare del peso. 
#|   L'opzione RStudio per mostrare Chunk Output in Console è anche 
#|   evidenziata.
knitr::include_graphics("quarto/diamond-sizes-console-output.png")
```

Per produrre un report completo contenente tutto il testo, codice e risultati, cliccate "Render" o premete Cmd/Ctrl + Shift + K.
Potete anche farlo programmaticamente con `quarto::quarto_render("diamond-sizes.qmd")`.
Questo mostrerà il report nel pannello viewer come mostrato in @fig-diamond-sizes-report e creerà un file HTML.

```{r}
#| label: fig-diamond-sizes-report
#| echo: false
#| out-width: "90%"
#| fig-cap: |
#|   Un documento Quarto in RStudio con il documento renderizzato nel 
#|   pannello Viewer.
#| fig-alt: |
#|   Finestra RStudio con un documento Quarto intitolato "diamond-sizes.qmd" 
#|   a sinistra e il pannello Plot in basso a destra. Il documento 
#|   renderizzato non mostra alcun codice, ma il codice è visibile 
#|   nel documento sorgente.
knitr::include_graphics("quarto/diamond-sizes-report.png")
```

Quando renderizzate il documento, Quarto invia il file `.qmd` a **knitr**, <https://yihui.org/knitr/>, che esegue tutti i chunk di codice e crea un nuovo documento markdown (`.md`) che include il codice e il suo output.
Il file markdown generato da knitr viene poi processato da **pandoc**, [https://pandoc.org](https://pandoc.org/){.uri}, che è responsabile della creazione del file finito.
Questo processo è mostrato in @fig-quarto-flow.
Il vantaggio di questo workflow a due passi è che potete creare una vasta gamma di formati di output, come imparerete in @sec-quarto-formats.

```{r}
#| label: fig-quarto-flow
#| echo: false
#| out-width: "75%"
#| fig-alt: |
#|   Diagramma di workflow che inizia con un file qmd, poi knitr, poi md, 
#|   poi pandoc, poi PDF, MS Word, o HTML.
#| fig-cap: |
#|   Diagramma del workflow Quarto da qmd, a knitr, a md, a pandoc, 
#|   a output in formati PDF, MS Word, o HTML.
knitr::include_graphics("images/quarto-flow.png")
```

Per iniziare con il vostro file `.qmd`, selezionate *File \> New File \> Quarto Document...* nella barra del menu.
RStudio lancerà una procedura guidata che potete usare per pre-popolare il vostro file con contenuto utile che vi ricorda come funzionano le caratteristiche chiave di Quarto.

Le sezioni seguenti approfondiscono i tre componenti di un documento Quarto in maggior dettaglio: il testo markdown, i chunk di codice e l'header YAML.

### Esercizi

1.  Create un nuovo documento Quarto usando *File \> New File \> Quarto Document*.
    Leggete le istruzioni.
    Esercitatevi ad eseguire i chunk individualmente.
    Poi renderizzate il documento cliccando il bottone appropriato e poi usando la scorciatoia da tastiera appropriata.
    Verificate che potete modificare il codice, ri-eseguirlo e vedere l'output modificato.

2.  Create un nuovo documento Quarto per ognuno dei tre formati integrati: HTML, PDF e Word.
    Renderizzate ognuno dei tre documenti.
    Come differiscono gli output?
    Come differiscono gli input?
    (Potreste dover installare LaTeX per costruire l'output PDF --- RStudio vi avviserà se questo è necessario.)

## Editor visuale

L'editor visuale in RStudio fornisce un'interfaccia [WYSIWYM](https://en.wikipedia.org/wiki/WYSIWYM) per creare documenti Quarto.
Sotto il cofano, la prosa nei documenti Quarto (file `.qmd`) è scritta in Markdown, un set leggero di convenzioni per formattare file di testo semplice.
In realtà, Quarto usa Pandoc markdown (una versione leggermente estesa di Markdown che Quarto capisce), inclusi tabelle, citazioni, riferimenti incrociati, note a piè di pagina, div/span, liste di definizioni, attributi, HTML/TeX raw e altro ancora così come supporto per eseguire celle di codice e visualizzare il loro output inline.
Mentre Markdown è progettato per essere facile da leggere e scrivere, come vedrete in @sec-source-editor, richiede ancora l'apprendimento di nuova sintassi.
Pertanto, se siete nuovi ai documenti computazionali come i file `.qmd` ma avete esperienza usando strumenti come Google Docs o MS Word, il modo più facile per iniziare con Quarto in RStudio è l'editor visuale.

Nell'editor visuale potete usare i bottoni sulla barra del menu per inserire immagini, tabelle, riferimenti incrociati, ecc. oppure potete usare la scorciatoia universale <kbd>⌘</kbd> + <kbd>/</kbd> o <kbd>Ctrl</kbd> + <kbd>/</kbd> per inserire praticamente qualsiasi cosa.
Se siete all'inizio di una riga (come mostrato in @fig-visual-editor), potete anche inserire solo <kbd>/</kbd> per invocare la scorciatoia.

```{r}
#| label: fig-visual-editor
#| echo: false
#| out-width: "75%"
#| fig-cap: |
#|   Editor visuale Quarto.
#| fig-alt: |
#|   Un documento Quarto che mostra varie caratteristiche dell' 
#|   editor visuale come formattazione del testo (corsivo, grassetto, 
#|   sottolineato, maiuscoletto, codice, apice e pedice),
#|   intestazioni di primo, secondo e terzo livello, liste puntate e numerate,
#|   link, frasi collegate, e immagini (insieme a una 
#|   finestra pop-up per personalizzare la dimensione dell'immagine, aggiungere una 
#|   didascalia e testo alternativo, ecc.), tabelle con una riga di intestazione, 
#|   e lo strumento inserisci qualsiasi cosa con opzioni per inserire un 
#|   chunk di codice R, un chunk di codice Python, un div, una lista puntata, 
#|   una lista numerata, o un'intestazione di primo livello (le poche 
#|   scelte principali nello strumento).
knitr::include_graphics("quarto/quarto-visual-editor.png")
```

L'inserimento di immagini e la personalizzazione di come vengono visualizzate è anche facilitato con l'editor visuale.
Potete incollare un'immagine dalla vostra clipboard direttamente nell'editor visuale (e RStudio piazzerà una copia di quell'immagine nella directory del progetto e la collegherà) oppure potete usare il menu Insert \> Figure / Image dell'editor visuale per navigare all'immagine che volete inserire o incollare il suo URL.
Inoltre, usando lo stesso menu potete ridimensionare l'immagine così come aggiungere una didascalia, testo alternativo e un link.

L'editor visuale ha molte più caratteristiche che non abbiamo elencato qui che potreste trovare utili man mano che acquisite esperienza nell'authoring con esso.

Più importante, mentre l'editor visuale mostra il vostro contenuto con formattazione, sotto il cofano, salva il vostro contenuto in Markdown semplice e potete passare avanti e indietro tra gli editor visuale e sorgente per visualizzare e modificare il vostro contenuto usando entrambi gli strumenti.

### Esercizi

1.  Ricreate il documento in @fig-visual-editor usando l'editor visuale.
2.  Usando l'editor visuale, inserite un chunk di codice usando il menu Insert e poi lo strumento inserisci qualsiasi cosa.
3.  Usando l'editor visuale, scoprite come:
    a.  Aggiungere una nota a piè di pagina.
    b.  Aggiungere una riga orizzontale.
    c.  Aggiungere una citazione a blocco.
4.  Nell'editor visuale, andate su Insert \> Citation e inserite una citazione al paper intitolato [Welcome to the Tidyverse](https://joss.theoj.org/papers/10.21105/joss.01686) usando il suo DOI (digital object identifier), che è [10.21105/joss.01686](https://doi.org/10.21105/joss.01686). Renderizzate il documento e osservate come appare il riferimento nel documento. Che cambiamento osservate nello YAML del vostro documento?

## Editor sorgente {#sec-source-editor}

Potete anche modificare i documenti Quarto usando l'editor sorgente in RStudio, senza l'assistenza dell'editor visuale.
Mentre l'editor visuale sembrerà familiare a coloro che hanno esperienza nello scrivere in strumenti come Google docs, l'editor sorgente sembrerà familiare a coloro che hanno esperienza nello scrivere script R o documenti R Markdown.
L'editor sorgente può anche essere utile per il debug di errori di sintassi Quarto poiché spesso è più facile catturare questi errori in testo semplice.

La guida qui sotto mostra come usare il Markdown di Pandoc per creare documenti Quarto nell'editor sorgente.

```{r}
#| echo: false
#| comment: ""
cat(readr::read_file("quarto/markdown.qmd"))
```

Il modo migliore per imparare questi è semplicemente provarli.
Ci vorranno alcuni giorni, ma presto diventeranno una seconda natura, e non dovrete pensarci.
Se dimenticate, potete accedere a un foglio di riferimento pratico con *Help \> Markdown Quick Reference*.

### Esercizi

1.  Esercitatevi su quello che avete imparato creando un breve CV.
    Il titolo dovrebbe essere il vostro nome, e dovreste includere intestazioni per (almeno) istruzione o lavoro.
    Ognuna delle sezioni dovrebbe includere una lista puntata di lavori/lauree.
    Evidenziate l'anno in grassetto.

2.  Usando l'editor sorgente e il riferimento rapido Markdown, scoprite come:

    a.  Aggiungere una nota a piè di pagina.
    b.  Aggiungere una riga orizzontale.
    c.  Aggiungere una citazione a blocco.

3.  Copiate e incollate i contenuti di `diamond-sizes.qmd` da <https://github.com/hadley/r4ds/tree/main/quarto> in un documento Quarto R locale.
    Verificate che potete eseguirlo, poi aggiungete testo dopo il poligono di frequenza che descrive le sue caratteristiche più sorprendenti.

4.  Create un documento in Google doc o MS Word (o localizzate un documento che avete creato precedentemente) con qualche contenuto in esso come intestazioni, hyperlink, testo formattato, ecc.
    Copiate i contenuti di questo documento e incollateli in un documento Quarto nell'editor visuale.
    Poi, passate all'editor sorgente e ispezionate il codice sorgente.

## Chunk di codice

Per eseguire codice dentro un documento Quarto, dovete inserire un chunk.
Ci sono tre modi per farlo:

1.  La scorciatoia da tastiera Cmd + Option + I / Ctrl + Alt + I.

2.  L'icona del bottone "Insert" nella barra degli strumenti dell'editor.

3.  Digitando manualmente i delimitatori del chunk ```` ```{r} ```` e ```` ``` ````.

Vi raccomandiamo di imparare la scorciatoia da tastiera.
Vi farà risparmiare molto tempo nel lungo periodo!

Potete continuare a eseguire il codice usando la scorciatoia da tastiera che ormai (speriamo!) conoscete e amate: Cmd/Ctrl + Enter.
Tuttavia, i chunk hanno una nuova scorciatoia da tastiera: Cmd/Ctrl + Shift + Enter, che esegue tutto il codice nel chunk.
Pensate a un chunk come a una funzione.
Un chunk dovrebbe essere relativamente autosufficiente, e focalizzato su un singolo compito.

Le sezioni seguenti descrivono l'header del chunk che consiste di ```` ```{r} ````, seguito da un'etichetta opzionale del chunk e varie altre opzioni del chunk, ognuna sulla propria riga, marcata da `#|`.

### Etichetta del chunk

I chunk possono avere un'etichetta opzionale, ad es.

```{r}
#| echo: fenced
#| label: simple-addition
1 + 1
```

Questo ha tre vantaggi:

1.  Potete navigare più facilmente a chunk specifici usando il navigatore di codice a tendina in basso a sinistra dell'editor di script:

    ```{r}
    #| echo: false
    #| out-width: "30%"
    #| fig-alt: |
    #|   Frammento dell'IDE RStudio che mostra solo il navigatore di codice a tendina 
    #|   che mostra tre chunk. Il Chunk 1 è setup. Il Chunk 2 è cars e 
    #|   è in una sezione chiamata Quarto. Il Chunk 3 è pressure ed è in 
    #|   una sezione chiamata Including plots.
    knitr::include_graphics("screenshots/quarto-chunk-nav.png")
    ```

2.  I grafici prodotti dai chunk avranno nomi utili che li rendono più facili da usare altrove.
    Maggiori dettagli in @sec-figures.

3.  Potete impostare reti di chunk cached per evitare di ri-eseguire calcoli costosi a ogni esecuzione.
    Maggiori dettagli in @sec-caching.

Le vostre etichette dei chunk dovrebbero essere brevi ma evocative e non dovrebbero contenere spazi.
Raccomandiamo di usare trattini (`-`) per separare le parole (invece di underscore, `_`) ed evitare altri caratteri speciali nelle etichette dei chunk.

Siete generalmente liberi di etichettare il vostro chunk come volete, ma c'è un nome di chunk che conferisce comportamento speciale: `setup`.
Quando siete in modalità notebook, il chunk chiamato setup sarà eseguito automaticamente una volta, prima che qualsiasi altro codice sia eseguito.

Inoltre, le etichette dei chunk non possono essere duplicate.
Ogni etichetta di chunk deve essere unica.

### Opzioni del chunk

L'output del chunk può essere personalizzato con **opzioni**, campi forniti all'header del chunk.
Knitr fornisce quasi 60 opzioni che potete usare per personalizzare i vostri chunk di codice.
Qui copriremo le opzioni più importanti del chunk che userete frequentemente.
Potete vedere la lista completa su [https://yihui.org/knitr/options](https://yihui.org/knitr/options/){.uri}.

Il set più importante di opzioni controlla se il vostro blocco di codice viene eseguito e quali risultati vengono inseriti nel report finito:

-   `eval: false` impedisce al codice di essere valutato.
    (E ovviamente se il codice non viene eseguito, nessun risultato sarà generato).
    Questo è utile per mostrare codice d'esempio, o per disabilitare un grande blocco di codice senza commentare ogni riga.

-   `include: false` esegue il codice, ma non mostra il codice o i risultati nel documento finale.
    Usate questo per codice di setup che non volete che ingombri il vostro report.

-   `echo: false` impedisce al codice, ma non ai risultati, di apparire nel file finito.
    Usate questo quando scrivete report destinati a persone che non vogliono vedere il codice R sottostante.

-   `message: false` o `warning: false` impedisce a messaggi o avvertimenti di apparire nel file finito.

-   `results: hide` nasconde l'output stampato; `fig-show: hide` nasconde i grafici.

-   `error: true` fa sì che il rendering continui anche se il codice restituisce un errore.
    Questo è raramente qualcosa che vorrete includere nella versione finale del vostro report, ma può essere molto utile se dovete fare debug di esattamente cosa sta succedendo dentro il vostro `.qmd`.
    È anche utile se state insegnando R e volete includere deliberatamente un errore.
    Il default, `error: false` fa fallire il rendering se c'è un singolo errore nel documento.

Ognuna di queste opzioni del chunk viene aggiunta all'header del chunk, seguendo `#|`, ad es., nel chunk seguente il risultato non viene stampato poiché `eval` è impostato a false.

```{r}
#| echo: fenced
#| label: simple-multiplication
#| eval: false
2 * 2
```

La tabella seguente riassume quali tipi di output ogni opzione sopprime:

| Opzione          | Esegui codice | Mostra codice | Output | Grafici | Messaggi | Avvertimenti |
|------------------|:-------------:|:-------------:|:------:|:-------:|:--------:|:------------:|
| `eval: false`    |       X       |               |   X    |    X    |    X     |      X       |
| `include: false` |               |       X       |   X    |    X    |    X     |      X       |
| `echo: false`    |               |       X       |        |         |          |              |
| `results: hide`  |               |               |   X    |         |          |              |
| `fig-show: hide` |               |               |        |    X    |          |              |
| `message: false` |               |               |        |         |    X     |              |
| `warning: false` |               |               |        |         |          |      X       |

### Opzioni globali

Man mano che lavorate di più con knitr, scoprirete che alcune delle opzioni di chunk predefinite non si adattano alle vostre esigenze e volete cambiarle.

Potete farlo aggiungendo le opzioni preferite nello YAML del documento, sotto `execute`.
Per esempio, se state preparando un report per un pubblico che non ha bisogno di vedere il vostro codice ma solo i vostri risultati e narrativa, potreste impostare `echo: false` a livello di documento.
Questo nasconderà il codice per default, quindi mostrerà solo i chunk che scegliete deliberatamente di mostrare (con `echo: true`).
Potreste considerare di impostare `message: false` e `warning: false`, ma questo renderebbe più difficile fare debug dei problemi perché non vedreste alcun messaggio nel documento finale.

``` yaml
title: "My report"
execute:
  echo: false
```

Poiché Quarto è progettato per essere multi-linguaggio (funziona con R così come con altri linguaggi come Python, Julia, ecc.), tutte le opzioni knitr non sono disponibili a livello di esecuzione del documento poiché alcune di esse funzionano solo con knitr e non con altri motori che Quarto usa per eseguire codice in altri linguaggi (ad es., Jupyter).
Potete, tuttavia, ancora impostare queste come opzioni globali per il vostro documento sotto il campo `knitr`, sotto `opts_chunk`.
Per esempio, quando scriviamo libri e tutorial impostiamo:

``` yaml
title: "Tutorial"
knitr:
  opts_chunk:
    comment: "#>"
    collapse: true
```

Questo usa la nostra formattazione di commenti preferita e assicura che il codice e l'output siano tenuti strettamente intrecciati.

### Codice inline

C'è un altro modo per incorporare codice R in un documento Quarto: direttamente nel testo, con: `r inline()`.
Questo può essere molto utile se menzionate proprietà dei vostri dati nel testo.
Per esempio, il documento d'esempio usato all'inizio del capitolo aveva:

> Abbiamo dati su `r inline('nrow(diamonds)')` diamanti.
> Solo `r inline('nrow(diamonds) - nrow(smaller)')` sono più grandi di 2.5 carati.
> La distribuzione del resto è mostrata sotto:

Quando il report viene renderizzato, i risultati di questi calcoli vengono inseriti nel testo:

> Abbiamo dati su 53940 diamanti.
> Solo 126 sono più grandi di 2.5 carati.
> La distribuzione del resto è mostrata sotto:

Quando inserite numeri nel testo, `format()` è vostro amico.
Vi permette di impostare il numero di `digits` così non stampate con un grado ridicolo di precisione, e un `big.mark` per rendere i numeri più facili da leggere.
Potreste combinare questi in una funzione helper:

```{r}
comma <- function(x) format(x, digits = 2, big.mark = ",")
comma(3452345)
comma(.12358124331)
```

### Esercizi

1.  Aggiungete una sezione che esplora come le dimensioni dei diamanti variano per taglio, colore e chiarezza.
    Assumete che state scrivendo un report per qualcuno che non conosce R, e invece di impostare `echo: false` su ogni chunk, impostate un'opzione globale.

2.  Scaricate `diamond-sizes.qmd` da <https://github.com/hadley/r4ds/tree/main/quarto>.
    Aggiungete una sezione che descrive i 20 diamanti più grandi, includendo una tabella che mostra i loro attributi più importanti.

3.  Modificate `diamonds-sizes.qmd` per usare `label_comma()` per produrre output ben formattato.
    Includete anche la percentuale di diamanti che sono più grandi di 2.5 carati.

## Figure {#sec-figures}

Le figure in un documento Quarto possono essere incorporate (ad es., un file PNG o JPEG) o generate come risultato di un chunk di codice.

Per incorporare un'immagine da un file esterno, potete usare il menu Insert nell'Editor Visuale in RStudio e selezionare Figure / Image.
Questo aprirà un menu dove potete navigare all'immagine che volete inserire così come aggiungere testo alternativo o didascalia ad essa e regolare la sua dimensione.
Nell'editor visuale potete anche semplicemente incollare un'immagine dalla vostra clipboard nel vostro documento e RStudio piazzerà una copia di quell'immagine nella vostra cartella del progetto.

Se includete un chunk di codice che genera una figura (ad es., include una chiamata `ggplot()`), la figura risultante sarà automaticamente inclusa nel vostro documento Quarto.

### Dimensionamento delle figure

La sfida più grande dei grafici in Quarto è ottenere le vostre figure della dimensione e forma giuste.
Ci sono cinque opzioni principali che controllano il dimensionamento delle figure: `fig-width`, `fig-height`, `fig-asp`, `out-width` e `out-height`.
Il dimensionamento delle immagini è impegnativo perché ci sono due dimensioni (la dimensione della figura creata da R e la dimensione alla quale viene inserita nel documento di output), e modi multipli di specificare la dimensione (cioè altezza, larghezza e rapporto d'aspetto: scegliete due di tre).

Raccomandiamo tre delle cinque opzioni:

-   I grafici tendono ad essere più esteticamente piacevoli se hanno larghezza consistente.
    Per imporre questo, impostate `fig-width: 6` (6") e `fig-asp: 0.618` (la sezione aurea) nei default.
    Poi nei chunk individuali, aggiustate solo `fig-asp`.

-   Controllate la dimensione di output con `out-width` e impostatela a una percentuale della larghezza del corpo del documento di output.
    Suggeriamo `out-width: "70%"` e `fig-align: center`.

    Questo dà ai grafici spazio per respirare, senza occupare troppo spazio.

-   Per mettere grafici multipli in una singola riga, impostate `layout-ncol` a 2 per due grafici, 3 per tre grafici, ecc.
    Questo imposta effettivamente `out-width` a "50%" per ognuno dei vostri grafici se `layout-ncol` è 2, "33%" se `layout-ncol` è 3, ecc.
    A seconda di quello che state cercando di illustrare (ad es., mostrare dati o mostrare variazioni del grafico), potreste anche aggiustare `fig-width`, come discusso sotto.

Se scoprite che dovete strizzare gli occhi per leggere il testo nel vostro grafico, dovete aggiustare `fig-width`.
Se `fig-width` è più grande della dimensione con cui la figura viene renderizzata nel documento finale, il testo sarà troppo piccolo; se `fig-width` è più piccolo, il testo sarà troppo grande.
Spesso dovrete fare un po' di sperimentazione per capire il rapporto giusto tra `fig-width` e la larghezza finale nel vostro documento.
Per illustrare il principio, i seguenti tre grafici hanno `fig-width` di 4, 6, e 8 rispettivamente:

```{r}
#| include: false
plot <- ggplot(mpg, aes(x = displ, y = hwy)) + geom_point()
```

```{r}
#| echo: false
#| fig-width: 4
#| out-width: "50%"
#| fig-alt: |
#|   Scatterplot di consumo autostradale vs. cilindrata delle auto, dove i punti 
#|   sono di dimensione normale e il testo e le etichette degli assi sono in dimensione del font simile 
#|   al testo circostante.
plot
```

```{r}
#| echo: false
#| fig-width: 6
#| out-width: "50%"
#| fig-alt: |
#|   Scatterplot di consumo autostradale vs. cilindrata delle auto, dove i punti 
#|   sono più piccoli del grafico precedente e il testo e le etichette degli assi sono 
#|   più piccoli del testo circostante.
plot
```

```{r}
#| echo: false
#| fig-width: 8
#| out-width: "50%"
#| fig-alt: |
#|   Scatterplot di consumo autostradale vs. cilindrata delle auto, dove i punti 
#|   sono ancora più piccoli del grafico precedente e il testo e le etichette degli assi sono 
#|   ancora più piccoli del testo circostante.
plot
```

Se volete assicurarvi che la dimensione del font sia consistente in tutte le vostre figure, ogni volta che impostate `out-width`, dovrete anche aggiustare `fig-width` per mantenere lo stesso rapporto con il vostro `out-width` predefinito.
Per esempio, se il vostro `fig-width` predefinito è 6 e `out-width` è "70%", quando impostate `out-width: "50%"` dovrete impostare `fig-width` a 4.3 (6 \* 0.5 / 0.7).

Il dimensionamento e la scalatura delle figure è un'arte e una scienza e ottenere le cose giuste può richiedere un approccio iterativo di prova ed errore.
Puoi imparare di più sul dimensionamento delle figure nel [blog post taking control of plot scaling](https://www.tidyverse.org/blog/2020/08/taking-control-of-plot-scaling/).

### Altre opzioni importanti

Quando mescolate codice e testo, come in questo libro, potete impostare `fig-show: hold` in modo che i grafici siano mostrati dopo il codice.
Questo ha il piacevole effetto collaterale di costringervi a spezzare grandi blocchi di codice con le loro spiegazioni.

Per aggiungere una didascalia al grafico, usate `fig-cap`.
In Quarto questo cambierà la figura da inline a "floating".

Se state producendo output PDF, il tipo di grafica predefinito è PDF.
Questo è un buon default perché i PDF sono grafici vettoriali di alta qualità.
Tuttavia, possono produrre grafici molto grandi e lenti se state visualizzando migliaia di punti.
In quel caso, impostate `fig-format: "png"` per forzare l'uso di PNG.
Sono di qualità leggermente inferiore, ma saranno molto più compatti.

È una buona idea nominare i chunk di codice che producono figure, anche se non etichettate di routine altri chunk.
L'etichetta del chunk è usata per generare il nome del file del grafico su disco, quindi nominare i vostri chunk rende molto più facile individuare i grafici e riusarli in altre circostanze (es., se volete velocemente inserire un singolo grafico in un'email).

### Esercizi

1.  Aprite `diamond-sizes.qmd` nell'editor visuale, trovate un'immagine di un diamante, copiatela e incollatela nel documento. Fate doppio clic sull'immagine e aggiungete una didascalia. Ridimensionate l'immagine e renderizzate il vostro documento. Osservate come l'immagine viene salvata nella vostra directory di lavoro corrente.
2.  Modificate l'etichetta del chunk di codice in `diamond-sizes.qmd` che genera un grafico per iniziare con il prefisso `fig-` e aggiungete una didascalia alla figura con l'opzione chunk `fig-cap`. Poi, modificate il testo sopra il chunk di codice per aggiungere un riferimento incrociato alla figura con Insert \> Cross Reference.
3.  Cambiate la dimensione della figura con le seguenti opzioni chunk, una alla volta, renderizzate il vostro documento e descrivete come cambia la figura.
    a.  `fig-width: 10`

    b.  `fig-height: 3`

    c.  `out-width: "100%"`

    d.  `out-width: "20%"`

## Tabelle

Simile alle figure, potete includere due tipi di tabelle in un documento Quarto.
Possono essere tabelle markdown che create direttamente nel vostro documento Quarto (usando il menu Insert Table) oppure possono essere tabelle generate come risultato di un chunk di codice.
In questa sezione ci concentreremo sui secondi, tabelle generate tramite calcolo.

Per default, Quarto stampa data frame e matrici come li vedreste nella console:

```{r}
mtcars[1:5, ]
```

Se preferite che i dati siano visualizzati con formattazione aggiuntiva potete usare la funzione `knitr::kable()`.
Il codice sotto genera @tbl-kable.

```{r}
#| label: tbl-kable
#| tbl-cap: Una kable knitr.
knitr::kable(mtcars[1:5, ], )
```

Leggete la documentazione per `?knitr::kable` per vedere gli altri modi in cui potete personalizzare la tabella.
Per personalizzazione ancora più profonda, considerate i pacchetti **gt**, **huxtable**, **reactable**, **kableExtra**, **xtable**, **stargazer**, **pander**, **tables** e **ascii**.
Ognuno fornisce un set di strumenti per restituire tabelle formattate dal codice R.

### Esercizi

1.  Aprite `diamond-sizes.qmd` nell'editor visuale, inserite un chunk di codice, e aggiungete una tabella con `knitr::kable()` che mostra le prime 5 righe del data frame `diamonds`.
2.  Visualizzate la stessa tabella con `gt::gt()` invece.
3.  Aggiungete un'etichetta di chunk che inizia con il prefisso `tbl-` e aggiungete una didascalia alla tabella con l'opzione chunk `tbl-cap`. Poi, modificate il testo sopra il chunk di codice per aggiungere un riferimento incrociato alla tabella con Insert \> Cross Reference.

## Caching {#sec-caching}

Normalmente, ogni rendering di un documento inizia da una lavagna completamente pulita.
Questo è ottimo per la riproducibilità, perché assicura che abbiate catturato ogni calcolo importante nel codice.
Tuttavia, può essere doloroso se avete dei calcoli che richiedono molto tempo.
La soluzione è `cache: true`.

Potete abilitare la cache di Knitr a livello di documento per mettere in cache i risultati di tutti i calcoli in un documento usando opzioni YAML standard:

``` yaml
---
title: "My Document"
execute: 
  cache: true
---
```

Potete anche abilitare la cache a livello di chunk per mettere in cache i risultati del calcolo in un chunk specifico:

```{r}
#| echo: fenced
#| cache: true
# code for lengthy computation...
```

Quando impostato, questo salverà l'output del chunk in un file con nome speciale su disco.
Nelle esecuzioni successive, knitr controllerà per vedere se il codice è cambiato, e se non è così, riuserà i risultati cached.

Il sistema di caching deve essere usato con cura, perché per default è basato solo sul codice, non sulle sue dipendenze.
Per esempio, qui il chunk `processed_data` dipende dal chunk `raw-data`:

````         
``` {{r}}
#| label: raw-data
#| cache: true
rawdata <- readr::read_csv("a_very_large_file.csv")
```
````

````         
``` {{r}}
#| label: processed_data
#| cache: true
processed_data <- rawdata |> 
  filter(!is.na(import_var)) |> 
  mutate(new_variable = complicated_transformation(x, y, z))
```
````

Mettere in cache il chunk `processed_data` significa che verrà ri-eseguito se la pipeline dplyr viene cambiata, ma non verrà ri-eseguito se la chiamata `read_csv()` cambia.
Potete evitare quel problema con l'opzione chunk `dependson`:

````         
``` {{r}}
#| label: processed-data
#| cache: true
#| dependson: "raw-data"
processed_data <- rawdata |> 
  filter(!is.na(import_var)) |> 
  mutate(new_variable = complicated_transformation(x, y, z))
```
````

`dependson` dovrebbe contenere un vettore di caratteri di *ogni* chunk da cui dipende il chunk cached.
Knitr aggiornerà i risultati per il chunk cached ogni volta che rileva che una delle sue dipendenze è cambiata.

Notate che i chunk non si aggiorneranno se `a_very_large_file.csv` cambia, perché il caching di knitr traccia solo i cambiamenti all'interno del file `.qmd`.
Se volete anche tracciare i cambiamenti a quel file potete usare l'opzione `cache.extra`.
Questa è un'espressione R arbitraria che invaliderà la cache ogni volta che cambia.
Una buona funzione da usare è `file.mtime()`: restituisce quando è stato modificato l'ultima volta.
Poi potete scrivere:

````         
``` {{r}}
#| label: raw-data
#| cache: true
#| cache.extra: !expr file.mtime("a_very_large_file.csv")
rawdata <- readr::read_csv("a_very_large_file.csv")
```
````

Abbiamo seguito il consiglio di [David Robinson](https://twitter.com/drob/status/738786604731490304) per nominare questi chunk: ogni chunk è nominato secondo l'oggetto principale che crea.
Questo rende più facile capire la specifica `dependson`.

Mentre le vostre strategie di caching diventano progressivamente più complicate, è una buona idea pulire regolarmente tutte le vostre cache con `knitr::clean_cache()`.

### Esercizi

1.  Impostate una rete di chunk dove `d` dipende da `c` e `b`, e sia `b` che `c` dipendono da `a`. Fate stampare a ogni chunk `lubridate::now()`, impostate `cache: true`, poi verificate la vostra comprensione del caching.

## Risoluzione dei problemi

La risoluzione dei problemi dei documenti Quarto può essere impegnativa perché non siete più in un ambiente R interattivo, e dovrete imparare alcuni nuovi trucchi.
Inoltre, l'errore potrebbe essere dovuto a problemi con il documento Quarto stesso o al codice R nel documento Quarto.

Un errore comune nei documenti con chunk di codice sono le etichette dei chunk duplicate, che sono particolarmente pervasive se il vostro workflow coinvolge copiare e incollare chunk di codice.
Per affrontare questo problema, tutto quello che dovete fare è cambiare una delle vostre etichette duplicate.

Se gli errori sono dovuti al codice R nel documento, la prima cosa che dovreste sempre provare è ricreare il problema in una sessione interattiva.
Riavviate R, poi "Run all chunks", sia dal menu Code, sotto Run region o con la scorciatoia da tastiera Ctrl + Alt + R.
Se siete fortunati, questo ricreerà il problema, e potrete capire cosa sta succedendo interattivamente.

Se questo non aiuta, ci deve essere qualcosa di diverso tra il vostro ambiente interattivo e l'ambiente Quarto.
Dovrete esplorare sistematicamente le opzioni.
La differenza più comune è la directory di lavoro: la directory di lavoro di un Quarto è la directory in cui vive.
Controllate che la directory di lavoro sia quella che vi aspettate includendo `getwd()` in un chunk.

Successivamente, fate brainstorming su tutte le cose che potrebbero causare il bug.
Dovrete controllare sistematicamente che siano le stesse nella vostra sessione R e nella vostra sessione Quarto.
Il modo più facile per farlo è impostare `error: true` sul chunk che causa il problema, poi usare `print()` e `str()` per controllare che le impostazioni siano come vi aspettate.

## Header YAML

Potete controllare molte altre impostazioni "dell'intero documento" modificando i parametri dell'header YAML.
Potreste chiedervi cosa significa YAML: è "YAML Ain't Markup Language", che è progettato per rappresentare dati gerarchici in un modo che è facile da leggere e scrivere per gli esseri umani.
Quarto lo usa per controllare molti dettagli dell'output.
Qui ne discuteremo tre: documenti auto-contenuti, parametri del documento e bibliografie.

### Auto-contenuto

I documenti HTML tipicamente hanno un numero di dipendenze esterne (es., immagini, fogli di stile CSS, JavaScript, ecc.) e, per default, Quarto piazza queste dipendenze in una cartella `_files` nella stessa directory del vostro file `.qmd`.
Se pubblicate il file HTML su una piattaforma di hosting (es., QuartoPub, <https://quartopub.com/>), le dipendenze in questa directory sono pubblicate con il vostro documento e quindi sono disponibili nel report pubblicato.
Tuttavia, se volete inviare per email il report a un collega, potreste preferire avere un singolo documento HTML auto-contenuto che incorpora tutte le sue dipendenze.
Potete farlo specificando l'opzione `embed-resources`:

``` yaml
format:
  html:
    embed-resources: true
```

Il file risultante sarà auto-contenuto, tale che non avrà bisogno di file esterni e nessun accesso a internet per essere visualizzato correttamente da un browser.

### Parametri

I documenti Quarto possono includere uno o più parametri i cui valori possono essere impostati quando renderizzate il report.
I parametri sono utili quando volete ri-renderizzare lo stesso report con valori distinti per vari input chiave.
Per esempio, potreste produrre report di vendite per filiale, risultati d'esame per studente, o riassunti demografici per paese.
Per dichiarare uno o più parametri, usate il campo `params`.

Questo esempio usa un parametro `my_class` per determinare quale classe di auto visualizzare:

```{r}
#| echo: false
#| out-width: "100%"
#| comment: ""
cat(readr::read_file("quarto/fuel-economy.qmd"))
```

Come potete vedere, i parametri sono disponibili all'interno dei chunk di codice come lista di sola lettura chiamata `params`.

Potete scrivere vettori atomici direttamente nell'header YAML.
Potete anche eseguire espressioni R arbitrarie prefissando il valore del parametro con `!expr`.
Questo è un buon modo per specificare parametri data/ora.

``` yaml
params:
  start: !expr lubridate::ymd("2015-01-01")
  snapshot: !expr lubridate::ymd_hms("2015-01-01 12:30:00")
```

### Bibliografie e citazioni

Quarto può generare automaticamente citazioni e una bibliografia in un numero di stili.
Il modo più diretto di aggiungere citazioni e bibliografie a un documento Quarto è usando l'editor visuale in RStudio.

Per aggiungere una citazione usando l'editor visuale, andate su Insert \> Citation.
Le citazioni possono essere inserite da una varietà di fonti:

1.  Riferimenti [DOI](https://quarto.org/docs/visual-editor/technical.html#citations-from-dois) (Document Object Identifier).

2.  Librerie personali o di gruppo [Zotero](https://quarto.org/docs/visual-editor/technical.html#citations-from-zotero).

3.  Ricerche di [Crossref](https://www.crossref.org/), [DataCite](https://datacite.org/), o [PubMed](https://pubmed.ncbi.nlm.nih.gov/).

4.  La bibliografia del vostro documento (un file `.bib` nella directory del vostro documento)

Sotto il cofano, la modalità visuale usa la rappresentazione markdown Pandoc standard per le citazioni (es., `[@citation]`).

Se aggiungete una citazione usando uno dei primi tre metodi, l'editor visuale creerà automaticamente un file `bibliography.bib` per voi e aggiungerà il riferimento ad esso.
Aggiungerà anche un campo `bibliography` al YAML del documento.
Mentre aggiungete più riferimenti, questo file verrà popolato con le loro citazioni.
Potete anche modificare direttamente questo file usando molti formati di bibliografia comuni inclusi BibLaTeX, BibTeX, EndNote, Medline.

Per creare una citazione all'interno del vostro file .qmd nell'editor sorgente, usate una chiave composta da '\@' + l'identificatore della citazione dal file bibliografia.
Poi piazzate la citazione tra parentesi quadre.
Ecco alcuni esempi:

``` markdown
Separate multiple citations with a `;`: Blah blah [@smith04; @doe99].

You can add arbitrary comments inside the square brackets: 
Blah blah [see @doe99, pp. 33-35; also @smith04, ch. 1].

Remove the square brackets to create an in-text citation: @smith04 
says blah, or @smith04 [p. 33] says blah.

Add a `-` before the citation to suppress the author's name: 
Smith says blah [-@smith04].
```

Quando Quarto renderizza il vostro file, costruirà e appenderà una bibliografia alla fine del vostro documento.
La bibliografia conterrà ognuno dei riferimenti citati dal vostro file bibliografia, ma non conterrà un'intestazione di sezione.
Di conseguenza è pratica comune finire il vostro file con un'intestazione di sezione per la bibliografia, come `# References` o `# Bibliography`.

Potete cambiare lo stile delle vostre citazioni e bibliografia referenziando un file CSL (citation style language) nel campo `csl`:

``` yaml
bibliography: rmarkdown.bib
csl: apa.csl
```

Come con il campo bibliografia, il vostro file csl dovrebbe contenere un percorso al file.
Qui assumiamo che il file csl sia nella stessa directory del file .qmd.
Un buon posto per trovare file di stile CSL per stili di bibliografia comuni è <https://github.com/citation-style-language/styles>.

## Workflow

Prima, abbiamo discusso un workflow di base per catturare il vostro codice R dove lavorate interattivamente nella *console*, poi catturate quello che funziona nell'*editor di script*.
Quarto unisce la console e l'editor di script, offuscando le linee tra esplorazione interattiva e cattura di codice a lungo termine.
Potete iterare rapidamente all'interno di un chunk, modificando e ri-eseguendo con Cmd/Ctrl + Shift + Enter.
Quando siete soddisfatti, andate avanti e iniziate un nuovo chunk.

Quarto è anche importante perché integra così strettamente prosa e codice.
Questo lo rende un ottimo **notebook di analisi** perché vi permette di sviluppare codice e registrare i vostri pensieri.
Un notebook di analisi condivide molti degli stessi obiettivi di un classico quaderno di laboratorio nelle scienze fisiche.
Esso:

-   Registra quello che avete fatto e perché l'avete fatto.
    Indipendentemente da quanto sia buona la vostra memoria, se non registrate quello che fate, arriverà un momento in cui avrete dimenticato dettagli importanti.
    Scriveteli giù così non dimenticate!

-   Supporta il pensiero rigoroso.
    È più probabile che troviate un'analisi forte se registrate i vostri pensieri mentre andate avanti, e continuate a riflettere su di essi.
    Questo vi fa anche risparmiare tempo quando alla fine scrivete la vostra analisi per condividerla con altri.

-   Aiuta altri a capire il vostro lavoro.
    È raro fare analisi dei dati da soli, e spesso lavorerete come parte di un team.
    Un quaderno di laboratorio vi aiuta a condividere non solo quello che avete fatto, ma perché l'avete fatto con i vostri colleghi o compagni di laboratorio.

Molti dei buoni consigli sull'uso efficace dei quaderni di laboratorio possono anche essere tradotti in notebook di analisi.
Abbiamo attinto alle nostre esperienze e ai consigli di Colin Purrington sui quaderni di laboratorio (<https://colinpurrington.com/tips/lab-notebooks>) per arrivare ai seguenti suggerimenti:

-   Assicuratevi che ogni notebook abbia un titolo descrittivo, un nome file evocativo e un primo paragrafo che descriva brevemente gli obiettivi dell'analisi.

-   Usate il campo data dell'header YAML per registrare la data in cui avete iniziato a lavorare sul notebook:

    ``` yaml
    date: 2016-08-23
    ```

    Usate il formato ISO8601 YYYY-MM-DD così non c'è ambiguità.
    Usatelo anche se normalmente non scrivete le date in quel modo!

-   Se spendete molto tempo su un'idea di analisi e si rivela essere un vicolo cieco, non cancellatela!
    Scrivete una breve nota su perché è fallita e lasciatela nel notebook.
    Questo vi aiuterà a evitare di andare nello stesso vicolo cieco quando tornerete all'analisi in futuro.

-   Generalmente, è meglio fare l'inserimento dati fuori da R.
    Ma se dovete registrare un piccolo frammento di dati, disponetelo chiaramente usando `tibble::tribble()`.

-   Se scoprite un errore in un file di dati, non modificatelo mai direttamente, ma invece scrivete codice per correggere il valore.
    Spiegate perché avete fatto la correzione.

-   Prima di finire per la giornata, assicuratevi di poter renderizzare il notebook.
    Se state usando il caching, assicuratevi di pulire le cache.
    Questo vi permetterà di correggere qualsiasi problema mentre il codice è ancora fresco nella vostra mente.

-   Se volete che il vostro codice sia riproducibile nel lungo termine (cioè così potete tornare a eseguirlo il mese prossimo o l'anno prossimo), dovrete tracciare le versioni dei pacchetti che il vostro codice usa.
    Un approccio rigoroso è usare **renv**, <https://rstudio.github.io/renv/index.html>, che memorizza i pacchetti nella directory del vostro progetto.
    Un trucco veloce e sporco è includere un chunk che esegue `sessionInfo()` --- questo non vi permetterà di ricreare facilmente i vostri pacchetti come sono oggi, ma almeno saprete cosa erano.

-   Creerete molti, molti, molti notebook di analisi nel corso della vostra carriera.
    Come li organizzerete così potete trovarli di nuovo in futuro?
    Raccomandiamo di memorizzarli in progetti individuali, e di trovare un buono schema di denominazione.

## Riassunto

In questo capitolo vi abbiamo introdotto a Quarto per creare e pubblicare documenti computazionali riproducibili che includono il vostro codice e la vostra prosa in un posto.
Avete imparato a scrivere documenti Quarto in RStudio con l'editor visuale o sorgente, come funzionano i chunk di codice e come personalizzare le opzioni per essi, come includere figure e tabelle nei vostri documenti Quarto, e opzioni per il caching per i calcoli.
Inoltre, avete imparato ad aggiustare le opzioni header YAML per creare documenti autocontenuti o parametrizzati così come includere citazioni e bibliografia.
Vi abbiamo anche dato alcuni consigli per troubleshooting e workflow.

Mentre questa introduzione dovrebbe essere sufficiente per iniziare con Quarto, c'è ancora molto altro da imparare.
Quarto è ancora relativamente giovane, e sta ancora crescendo rapidamente.
Il posto migliore per rimanere aggiornati sulle innovazioni è il sito web ufficiale di Quarto: [https://quarto.org](https://quarto.org/){.uri}.

Ci sono due argomenti importanti che non abbiamo coperto qui: collaborazione e i dettagli di comunicare accuratamente le vostre idee ad altri esseri umani.
La collaborazione è una parte vitale della data science moderna, e potete rendere la vostra vita molto più facile usando strumenti di controllo versione, come Git e GitHub.
Raccomandiamo "Happy Git with R", un'introduzione user-friendly a Git e GitHub per utenti R, di Jenny Bryan.
Il libro è liberamente disponibile online: <https://happygitwithr.com>.

Non abbiamo anche toccato cosa dovreste effettivamente scrivere per comunicare chiaramente i risultati della vostra analisi.
Per migliorare la vostra scrittura, raccomandiamo vivamente di leggere o [*Style: Lessons in Clarity and Grace*](https://www.amazon.com/Style-Lessons-Clarity-Grace-12th/dp/0134080416) di Joseph M. Williams & Joseph Bizup, o [*The Sense of Structure: Writing from the Reader's Perspective*](https://www.amazon.com/Sense-Structure-Writing-Readers-Perspective/dp/0205296327) di George Gopen.
Both books will help you understand the structure of sentences and paragraphs, and give you the tools to make your writing more clear.
(These books are rather expensive if purchased new, but they're used by many English classes so there are plenty of cheap second-hand copies).
George Gopen also has a number of short articles on writing at <https://www.georgegopen.com/litigation-articles.html>.
They are aimed at lawyers, but almost everything applies to data scientists too.
