# Quarto {#sec-quarto}

```{r}
#| echo: false
source("_common.R")
```

## Introduzione

Quarto fornisce un framework di authoring unificato per la data science, combinando il vostro codice, i suoi risultati e la vostra prosa.
I documenti Quarto sono completamente riproducibili e supportano dozzine di formati di output, come PDF, file Word, presentazioni e altro.

I file Quarto sono progettati per essere usati in tre modi:

1.  Per comunicare ai decisori, che vogliono concentrarsi sulle conclusioni, non sul codice dietro l'analisi.

2.  Per collaborare con altri data scientist (incluso il voi del futuro!), che sono interessati sia alle vostre conclusioni, sia a come ci siete arrivati (cioè il codice).

3.  Come ambiente in cui *fare* data science, come un quaderno di laboratorio moderno dove potete catturare non solo quello che avete fatto, ma anche quello che stavate pensando.

Quarto è uno strumento da riga di comando, non un pacchetto R.
Questo significa che l'aiuto, in generale, non è disponibile tramite `?`.
Invece, mentre lavorate attraverso questo capitolo e usate Quarto in futuro, dovreste fare riferimento alla [documentazione Quarto](https://quarto.org).

Se siete utenti di R Markdown, potreste pensare "Quarto suona molto come R Markdown".
Non sbagliate!
Quarto unifica la funzionalità di molti pacchetti dall'ecosistema R Markdown (rmarkdown, bookdown, distill, xaringan, ecc.) in un singolo sistema coerente e lo estende anche con supporto nativo per più linguaggi di programmazione come Python e Julia oltre a R.
In un certo senso, Quarto riflette tutto quello che è stato imparato dall'espansione e supporto dell'ecosistema R Markdown in un decennio.

### Prerequisiti

Avete bisogno dell'interfaccia a riga di comando Quarto (Quarto CLI), ma non dovete installarla o caricarla esplicitamente, poiché RStudio fa automaticamente entrambe le cose quando necessario.

```{r}
#| label: setup
#| include: false
chunk <- "```"
inline <- function(x = "") paste0("`` `r ", x, "` ``")
library(tidyverse)
```

## Basi di Quarto

Questo è un file Quarto -- un file di testo semplice che ha l'estensione `.qmd`:

```{r echo = FALSE, comment = ""}
cat(readr::read_file("quarto/diamond-sizes.qmd"))
```

Contiene tre tipi importanti di contenuto:

1.  Un **header YAML** (opzionale) circondato da `---`.
2.  **Chunk** di codice R circondati da ```` ``` ````.
3.  Testo mescolato con formattazione semplice del testo come `# heading` e `_italics_`.

@fig-diamond-sizes-notebook mostra un documento `.qmd` in RStudio con interfaccia notebook dove codice e output sono intercalati.
Potete eseguire ogni chunk di codice cliccando sull'icona Run (sembra un bottone play in cima al chunk), o premendo Cmd/Ctrl + Shift + Enter.
RStudio esegue il codice e mostra i risultati inline con il codice.

```{r}
#| label: fig-diamond-sizes-notebook
#| echo: false
#| out-width: "90%"
#| fig-cap: |
#|   Un documento Quarto in RStudio. Codice e output intercalati nel 
#|   documento, con l'output del grafico che appare proprio sotto il codice.
#| fig-alt: |
#|   Finestra RStudio con un documento Quarto intitolato "diamond-sizes.qmd" 
#|   a sinistra e una finestra Viewer vuota a destra. Il documento Quarto 
#|   ha un chunk di codice che crea un grafico di frequenza dei diamanti 
#|   che pesano meno di 2.5 carati. Il grafico mostra che la frequenza 
#|   diminuisce all'aumentare del peso.
knitr::include_graphics("quarto/diamond-sizes-notebook.png")
```

Se non vi piace vedere i vostri grafici e output nel vostro documento e preferite usare i pannelli Console e Plot di RStudio, potete cliccare sull'icona ingranaggio accanto a "Render" e passare a "Chunk Output in Console", come mostrato in @fig-diamond-sizes-console-output.

```{r}
#| label: fig-diamond-sizes-console-output
#| echo: false
#| out-width: "90%"
#| fig-cap: |
#|   Un documento Quarto in RStudio con l'output del grafico nel pannello Plots.
#| fig-alt: |
#|   Finestra RStudio con un documento Quarto intitolato "diamond-sizes.qmd" 
#|   a sinistra e il pannello Plot in basso a destra. Il documento Quarto 
#|   ha un chunk di codice che crea un grafico di frequenza dei diamanti 
#|   che pesano meno di 2.5 carati. Il grafico è mostrato nel pannello 
#|   Plot e mostra che la frequenza diminuisce all'aumentare del peso. 
#|   L'opzione RStudio per mostrare Chunk Output in Console è anche 
#|   evidenziata.
knitr::include_graphics("quarto/diamond-sizes-console-output.png")
```

Per produrre un report completo contenente tutto il testo, codice e risultati, cliccate "Render" o premete Cmd/Ctrl + Shift + K.
Potete anche farlo programmaticamente con `quarto::quarto_render("diamond-sizes.qmd")`.
Questo mostrerà il report nel pannello viewer come mostrato in @fig-diamond-sizes-report e creerà un file HTML.

```{r}
#| label: fig-diamond-sizes-report
#| echo: false
#| out-width: "90%"
#| fig-cap: |
#|   Un documento Quarto in RStudio con il documento renderizzato nel 
#|   pannello Viewer.
#| fig-alt: |
#|   Finestra RStudio con un documento Quarto intitolato "diamond-sizes.qmd" 
#|   a sinistra e il pannello Plot in basso a destra. Il documento 
#|   renderizzato non mostra alcun codice, ma il codice è visibile 
#|   nel documento sorgente.
knitr::include_graphics("quarto/diamond-sizes-report.png")
```

Quando renderizzate il documento, Quarto invia il file `.qmd` a **knitr**, <https://yihui.org/knitr/>, che esegue tutti i chunk di codice e crea un nuovo documento markdown (`.md`) che include il codice e il suo output.
Il file markdown generato da knitr viene poi processato da **pandoc**, [https://pandoc.org](https://pandoc.org/){.uri}, che è responsabile della creazione del file finito.
Questo processo è mostrato in @fig-quarto-flow.
Il vantaggio di questo workflow a due passi è che potete creare una vasta gamma di formati di output, come imparerete in @sec-quarto-formats.

```{r}
#| label: fig-quarto-flow
#| echo: false
#| out-width: "75%"
#| fig-alt: |
#|   Diagramma di workflow che inizia con un file qmd, poi knitr, poi md, 
#|   poi pandoc, poi PDF, MS Word, o HTML.
#| fig-cap: |
#|   Diagramma del workflow Quarto da qmd, a knitr, a md, a pandoc, 
#|   a output in formati PDF, MS Word, o HTML.
knitr::include_graphics("images/quarto-flow.png")
```

Per iniziare con il vostro file `.qmd`, selezionate *File \> New File \> Quarto Document...* nella barra del menu.
RStudio lancerà una procedura guidata che potete usare per pre-popolare il vostro file con contenuto utile che vi ricorda come funzionano le caratteristiche chiave di Quarto.

Le sezioni seguenti approfondiscono i tre componenti di un documento Quarto in maggior dettaglio: il testo markdown, i chunk di codice e l'header YAML.

### Esercizi

1.  Create un nuovo documento Quarto usando *File \> New File \> Quarto Document*.
    Leggete le istruzioni.
    Esercitatevi ad eseguire i chunk individualmente.
    Poi renderizzate il documento cliccando il bottone appropriato e poi usando la scorciatoia da tastiera appropriata.
    Verificate che potete modificare il codice, ri-eseguirlo e vedere l'output modificato.

2.  Create un nuovo documento Quarto per ognuno dei tre formati integrati: HTML, PDF e Word.
    Renderizzate ognuno dei tre documenti.
    Come differiscono gli output?
    Come differiscono gli input?
    (Potreste dover installare LaTeX per costruire l'output PDF --- RStudio vi avviserà se questo è necessario.)

## Editor visuale

L'editor visuale in RStudio fornisce un'interfaccia [WYSIWYM](https://en.wikipedia.org/wiki/WYSIWYM) per creare documenti Quarto.
Sotto il cofano, la prosa nei documenti Quarto (file `.qmd`) è scritta in Markdown, un set leggero di convenzioni per formattare file di testo semplice.
In realtà, Quarto usa Pandoc markdown (una versione leggermente estesa di Markdown che Quarto capisce), inclusi tabelle, citazioni, riferimenti incrociati, note a piè di pagina, div/span, liste di definizioni, attributi, HTML/TeX raw e altro ancora così come supporto per eseguire celle di codice e visualizzare il loro output inline.
Mentre Markdown è progettato per essere facile da leggere e scrivere, come vedrete in @sec-source-editor, richiede ancora l'apprendimento di nuova sintassi.
Pertanto, se siete nuovi ai documenti computazionali come i file `.qmd` ma avete esperienza usando strumenti come Google Docs o MS Word, il modo più facile per iniziare con Quarto in RStudio è l'editor visuale.

Nell'editor visuale potete usare i bottoni sulla barra del menu per inserire immagini, tabelle, riferimenti incrociati, ecc. oppure potete usare la scorciatoia universale <kbd>⌘</kbd> + <kbd>/</kbd> o <kbd>Ctrl</kbd> + <kbd>/</kbd> per inserire praticamente qualsiasi cosa.
Se siete all'inizio di una riga (come mostrato in @fig-visual-editor), potete anche inserire solo <kbd>/</kbd> per invocare la scorciatoia.

```{r}
#| label: fig-visual-editor
#| echo: false
#| out-width: "75%"
#| fig-cap: |
#|   Editor visuale Quarto.
#| fig-alt: |
#|   Un documento Quarto che mostra varie caratteristiche dell' 
#|   editor visuale come formattazione del testo (corsivo, grassetto, 
#|   sottolineato, maiuscoletto, codice, apice e pedice),
#|   intestazioni di primo, secondo e terzo livello, liste puntate e numerate,
#|   link, frasi collegate, e immagini (insieme a una 
#|   finestra pop-up per personalizzare la dimensione dell'immagine, aggiungere una 
#|   didascalia e testo alternativo, ecc.), tabelle con una riga di intestazione, 
#|   e lo strumento inserisci qualsiasi cosa con opzioni per inserire un 
#|   chunk di codice R, un chunk di codice Python, un div, una lista puntata, 
#|   una lista numerata, o un'intestazione di primo livello (le poche 
#|   scelte principali nello strumento).
knitr::include_graphics("quarto/quarto-visual-editor.png")
```

L'inserimento di immagini e la personalizzazione di come vengono visualizzate è anche facilitato con l'editor visuale.
Potete incollare un'immagine dalla vostra clipboard direttamente nell'editor visuale (e RStudio piazzerà una copia di quell'immagine nella directory del progetto e la collegherà) oppure potete usare il menu Insert \> Figure / Image dell'editor visuale per navigare all'immagine che volete inserire o incollare il suo URL.
Inoltre, usando lo stesso menu potete ridimensionare l'immagine così come aggiungere una didascalia, testo alternativo e un link.

L'editor visuale ha molte più caratteristiche che non abbiamo elencato qui che potreste trovare utili man mano che acquisite esperienza nell'authoring con esso.

Più importante, mentre l'editor visuale mostra il vostro contenuto con formattazione, sotto il cofano, salva il vostro contenuto in Markdown semplice e potete passare avanti e indietro tra gli editor visuale e sorgente per visualizzare e modificare il vostro contenuto usando entrambi gli strumenti.

### Esercizi

1.  Ricreate il documento in @fig-visual-editor usando l'editor visuale.
2.  Usando l'editor visuale, inserite un chunk di codice usando il menu Insert e poi lo strumento inserisci qualsiasi cosa.
3.  Usando l'editor visuale, scoprite come:
    a.  Aggiungere una nota a piè di pagina.
    b.  Aggiungere una riga orizzontale.
    c.  Aggiungere una citazione a blocco.
4.  Nell'editor visuale, andate su Insert \> Citation e inserite una citazione al paper intitolato [Welcome to the Tidyverse](https://joss.theoj.org/papers/10.21105/joss.01686) usando il suo DOI (digital object identifier), che è [10.21105/joss.01686](https://doi.org/10.21105/joss.01686). Renderizzate il documento e osservate come appare il riferimento nel documento. Che cambiamento osservate nello YAML del vostro documento?

## Editor sorgente {#sec-source-editor}

Potete anche modificare i documenti Quarto usando l'editor sorgente in RStudio, senza l'assistenza dell'editor visuale.
Mentre l'editor visuale sembrerà familiare a coloro che hanno esperienza nello scrivere in strumenti come Google docs, l'editor sorgente sembrerà familiare a coloro che hanno esperienza nello scrivere script R o documenti R Markdown.
L'editor sorgente può anche essere utile per il debug di errori di sintassi Quarto poiché spesso è più facile catturare questi errori in testo semplice.

La guida qui sotto mostra come usare il Markdown di Pandoc per creare documenti Quarto nell'editor sorgente.

```{r}
#| echo: false
#| comment: ""
cat(readr::read_file("quarto/markdown.qmd"))
```

Il modo migliore per imparare questi è semplicemente provarli.
Ci vorranno alcuni giorni, ma presto diventeranno una seconda natura, e non dovrete pensarci.
Se dimenticate, potete accedere a un foglio di riferimento pratico con *Help \> Markdown Quick Reference*.

### Esercizi

1.  Esercitatevi su quello che avete imparato creando un breve CV.
    Il titolo dovrebbe essere il vostro nome, e dovreste includere intestazioni per (almeno) istruzione o lavoro.
    Ognuna delle sezioni dovrebbe includere una lista puntata di lavori/lauree.
    Evidenziate l'anno in grassetto.

2.  Usando l'editor sorgente e il riferimento rapido Markdown, scoprite come:

    a.  Aggiungere una nota a piè di pagina.
    b.  Aggiungere una riga orizzontale.
    c.  Aggiungere una citazione a blocco.

3.  Copiate e incollate i contenuti di `diamond-sizes.qmd` da <https://github.com/hadley/r4ds/tree/main/quarto> in un documento Quarto R locale.
    Verificate che potete eseguirlo, poi aggiungete testo dopo il poligono di frequenza che descrive le sue caratteristiche più sorprendenti.

4.  Create un documento in Google doc o MS Word (o localizzate un documento che avete creato precedentemente) con qualche contenuto in esso come intestazioni, hyperlink, testo formattato, ecc.
    Copiate i contenuti di questo documento e incollateli in un documento Quarto nell'editor visuale.
    Poi, passate all'editor sorgente e ispezionate il codice sorgente.

## Chunk di codice

Per eseguire codice dentro un documento Quarto, dovete inserire un chunk.
Ci sono tre modi per farlo:

1.  La scorciatoia da tastiera Cmd + Option + I / Ctrl + Alt + I.

2.  L'icona del bottone "Insert" nella barra degli strumenti dell'editor.

3.  Digitando manualmente i delimitatori del chunk ```` ```{r} ```` e ```` ``` ````.

Vi raccomandiamo di imparare la scorciatoia da tastiera.
Vi farà risparmiare molto tempo nel lungo periodo!

Potete continuare a eseguire il codice usando la scorciatoia da tastiera che ormai (speriamo!) conoscete e amate: Cmd/Ctrl + Enter.
Tuttavia, i chunk hanno una nuova scorciatoia da tastiera: Cmd/Ctrl + Shift + Enter, che esegue tutto il codice nel chunk.
Pensate a un chunk come a una funzione.
Un chunk dovrebbe essere relativamente autosufficiente, e focalizzato su un singolo compito.

Le sezioni seguenti descrivono l'header del chunk che consiste di ```` ```{r} ````, seguito da un'etichetta opzionale del chunk e varie altre opzioni del chunk, ognuna sulla propria riga, marcata da `#|`.

### Etichetta del chunk

I chunk possono avere un'etichetta opzionale, ad es.

```{r}
#| echo: fenced
#| label: simple-addition
1 + 1
```

Questo ha tre vantaggi:

1.  Potete navigare più facilmente a chunk specifici usando il navigatore di codice a tendina in basso a sinistra dell'editor di script:

    ```{r}
    #| echo: false
    #| out-width: "30%"
    #| fig-alt: |
    #|   Frammento dell'IDE RStudio che mostra solo il navigatore di codice a tendina 
    #|   che mostra tre chunk. Il Chunk 1 è setup. Il Chunk 2 è cars e 
    #|   è in una sezione chiamata Quarto. Il Chunk 3 è pressure ed è in 
    #|   una sezione chiamata Including plots.
    knitr::include_graphics("screenshots/quarto-chunk-nav.png")
    ```

2.  I grafici prodotti dai chunk avranno nomi utili che li rendono più facili da usare altrove.
    Maggiori dettagli in @sec-figures.

3.  Potete impostare reti di chunk cached per evitare di ri-eseguire calcoli costosi a ogni esecuzione.
    Maggiori dettagli in @sec-caching.

Le vostre etichette dei chunk dovrebbero essere brevi ma evocative e non dovrebbero contenere spazi.
Raccomandiamo di usare trattini (`-`) per separare le parole (invece di underscore, `_`) ed evitare altri caratteri speciali nelle etichette dei chunk.

Siete generalmente liberi di etichettare il vostro chunk come volete, ma c'è un nome di chunk che conferisce comportamento speciale: `setup`.
Quando siete in modalità notebook, il chunk chiamato setup sarà eseguito automaticamente una volta, prima che qualsiasi altro codice sia eseguito.

Inoltre, le etichette dei chunk non possono essere duplicate.
Ogni etichetta di chunk deve essere unica.

### Opzioni del chunk

L'output del chunk può essere personalizzato con **opzioni**, campi forniti all'header del chunk.
Knitr fornisce quasi 60 opzioni che potete usare per personalizzare i vostri chunk di codice.
Qui copriremo le opzioni più importanti del chunk che userete frequentemente.
Potete vedere la lista completa su [https://yihui.org/knitr/options](https://yihui.org/knitr/options/){.uri}.

Il set più importante di opzioni controlla se il vostro blocco di codice viene eseguito e quali risultati vengono inseriti nel report finito:

-   `eval: false` impedisce al codice di essere valutato.
    (E ovviamente se il codice non viene eseguito, nessun risultato sarà generato).
    Questo è utile per mostrare codice d'esempio, o per disabilitare un grande blocco di codice senza commentare ogni riga.

-   `include: false` esegue il codice, ma non mostra il codice o i risultati nel documento finale.
    Usate questo per codice di setup che non volete che ingombri il vostro report.

-   `echo: false` impedisce al codice, ma non ai risultati, di apparire nel file finito.
    Usate questo quando scrivete report destinati a persone che non vogliono vedere il codice R sottostante.

-   `message: false` o `warning: false` impedisce a messaggi o avvertimenti di apparire nel file finito.

-   `results: hide` nasconde l'output stampato; `fig-show: hide` nasconde i grafici.

-   `error: true` fa sì che il rendering continui anche se il codice restituisce un errore.
    Questo è raramente qualcosa che vorrete includere nella versione finale del vostro report, ma può essere molto utile se dovete fare debug di esattamente cosa sta succedendo dentro il vostro `.qmd`.
    È anche utile se state insegnando R e volete includere deliberatamente un errore.
    Il default, `error: false` fa fallire il rendering se c'è un singolo errore nel documento.

Ognuna di queste opzioni del chunk viene aggiunta all'header del chunk, seguendo `#|`, ad es., nel chunk seguente il risultato non viene stampato poiché `eval` è impostato a false.

```{r}
#| echo: fenced
#| label: simple-multiplication
#| eval: false
2 * 2
```

La tabella seguente riassume quali tipi di output ogni opzione sopprime:

| Opzione          | Esegui codice | Mostra codice | Output | Grafici | Messaggi | Avvertimenti |
|------------------|:-------------:|:-------------:|:------:|:-------:|:--------:|:------------:|
| `eval: false`    |       X       |               |   X    |    X    |    X     |      X       |
| `include: false` |               |       X       |   X    |    X    |    X     |      X       |
| `echo: false`    |               |       X       |        |         |          |              |
| `results: hide`  |               |               |   X    |         |          |              |
| `fig-show: hide` |               |               |        |    X    |          |              |
| `message: false` |               |               |        |         |    X     |              |
| `warning: false` |               |               |        |         |          |      X       |

### Opzioni globali

Man mano che lavorate di più con knitr, scoprirete che alcune delle opzioni di chunk predefinite non si adattano alle vostre esigenze e volete cambiarle.

Potete farlo aggiungendo le opzioni preferite nello YAML del documento, sotto `execute`.
Per esempio, se state preparando un report per un pubblico che non ha bisogno di vedere il vostro codice ma solo i vostri risultati e narrativa, potreste impostare `echo: false` a livello di documento.
Questo nasconderà il codice per default, quindi mostrerà solo i chunk che scegliete deliberatamente di mostrare (con `echo: true`).
Potreste considerare di impostare `message: false` e `warning: false`, ma questo renderebbe più difficile fare debug dei problemi perché non vedreste alcun messaggio nel documento finale.

``` yaml
title: "My report"
execute:
  echo: false
```

Poiché Quarto è progettato per essere multi-linguaggio (funziona con R così come con altri linguaggi come Python, Julia, ecc.), tutte le opzioni knitr non sono disponibili a livello di esecuzione del documento poiché alcune di esse funzionano solo con knitr e non con altri motori che Quarto usa per eseguire codice in altri linguaggi (ad es., Jupyter).
Potete, tuttavia, ancora impostare queste come opzioni globali per il vostro documento sotto il campo `knitr`, sotto `opts_chunk`.
Per esempio, quando scriviamo libri e tutorial impostiamo:

``` yaml
title: "Tutorial"
knitr:
  opts_chunk:
    comment: "#>"
    collapse: true
```

Questo usa la nostra formattazione di commenti preferita e assicura che il codice e l'output siano tenuti strettamente intrecciati.

### Codice inline

C'è un altro modo per incorporare codice R in un documento Quarto: direttamente nel testo, con: `r inline()`.
Questo può essere molto utile se menzionate proprietà dei vostri dati nel testo.
Per esempio, il documento d'esempio usato all'inizio del capitolo aveva:

> Abbiamo dati su `r inline('nrow(diamonds)')` diamanti.
> Solo `r inline('nrow(diamonds) - nrow(smaller)')` sono più grandi di 2.5 carati.
> La distribuzione del resto è mostrata sotto:

Quando il report viene renderizzato, i risultati di questi calcoli vengono inseriti nel testo:

> Abbiamo dati su 53940 diamanti.
> Solo 126 sono più grandi di 2.5 carati.
> La distribuzione del resto è mostrata sotto:

Quando inserite numeri nel testo, `format()` è vostro amico.
Vi permette di impostare il numero di `digits` così non stampate con un grado ridicolo di precisione, e un `big.mark` per rendere i numeri più facili da leggere.
Potreste combinare questi in una funzione helper:

```{r}
comma <- function(x) format(x, digits = 2, big.mark = ",")
comma(3452345)
comma(.12358124331)
```

### Esercizi

1.  Aggiungete una sezione che esplora come le dimensioni dei diamanti variano per taglio, colore e chiarezza.
    Assumete che state scrivendo un report per qualcuno che non conosce R, e invece di impostare `echo: false` su ogni chunk, impostate un'opzione globale.

2.  Scaricate `diamond-sizes.qmd` da <https://github.com/hadley/r4ds/tree/main/quarto>.
    Aggiungete una sezione che descrive i 20 diamanti più grandi, includendo una tabella che mostra i loro attributi più importanti.

3.  Modificate `diamonds-sizes.qmd` per usare `label_comma()` per produrre output ben formattato.
    Includete anche la percentuale di diamanti che sono più grandi di 2.5 carati.

## Figure {#sec-figures}

Le figure in un documento Quarto possono essere incorporate (ad es., un file PNG o JPEG) o generate come risultato di un chunk di codice.

Per incorporare un'immagine da un file esterno, potete usare il menu Insert nell'Editor Visuale in RStudio e selezionare Figure / Image.
Questo aprirà un menu dove potete navigare all'immagine che volete inserire così come aggiungere testo alternativo o didascalia ad essa e regolare la sua dimensione.
Nell'editor visuale potete anche semplicemente incollare un'immagine dalla vostra clipboard nel vostro documento e RStudio piazzerà una copia di quell'immagine nella vostra cartella del progetto.

Se includete un chunk di codice che genera una figura (ad es., include una chiamata `ggplot()`), la figura risultante sarà automaticamente inclusa nel vostro documento Quarto.

### Dimensionamento delle figure

La sfida più grande dei grafici in Quarto è ottenere le vostre figure della dimensione e forma giuste.
Ci sono cinque opzioni principali che controllano il dimensionamento delle figure: `fig-width`, `fig-height`, `fig-asp`, `out-width` e `out-height`.
Il dimensionamento delle immagini è impegnativo perché ci sono due dimensioni (la dimensione della figura creata da R e la dimensione alla quale viene inserita nel documento di output), e modi multipli di specificare la dimensione (cioè altezza, larghezza e rapporto d'aspetto: scegliete due di tre).

Raccomandiamo tre delle cinque opzioni:

-   I grafici tendono ad essere più esteticamente piacevoli se hanno larghezza consistente.
    Per imporre questo, impostate `fig-width: 6` (6") e `fig-asp: 0.618` (la sezione aurea) nei default.
    Poi nei chunk individuali, aggiustate solo `fig-asp`.

-   Controllate la dimensione di output con `out-width` e impostatela a una percentuale della larghezza del corpo del documento di output.
    Suggeriamo `out-width: "70%"` e `fig-align: center`.

    Questo dà ai grafici spazio per respirare, senza occupare troppo spazio.

-   Per mettere grafici multipli in una singola riga, impostate `layout-ncol` a 2 per due grafici, 3 per tre grafici, ecc.
    Questo imposta effettivamente `out-width` a "50%" per ognuno dei vostri grafici se `layout-ncol` è 2, "33%" se `layout-ncol` è 3, ecc.
    A seconda di quello che state cercando di illustrare (ad es., mostrare dati o mostrare variazioni del grafico), potreste anche aggiustare `fig-width`, come discusso sotto.

Se scoprite che dovete strizzare gli occhi per leggere il testo nel vostro grafico, dovete aggiustare `fig-width`.
Se `fig-width` è più grande della dimensione con cui la figura viene renderizzata nel documento finale, il testo sarà troppo piccolo; se `fig-width` è più piccolo, il testo sarà troppo grande.
Spesso dovrete fare un po' di sperimentazione per capire il rapporto giusto tra `fig-width` e la larghezza finale nel vostro documento.
Per illustrare il principio, i seguenti tre grafici hanno `fig-width` di 4, 6, e 8 rispettivamente:

```{r}
#| include: false
plot <- ggplot(mpg, aes(x = displ, y = hwy)) + geom_point()
```

```{r}
#| echo: false
#| fig-width: 4
#| out-width: "50%"
#| fig-alt: |
#|   Scatterplot di consumo autostradale vs. cilindrata delle auto, dove i punti 
#|   sono di dimensione normale e il testo e le etichette degli assi sono in dimensione del font simile 
#|   al testo circostante.
plot
```

```{r}
#| echo: false
#| fig-width: 6
#| out-width: "50%"
#| fig-alt: |
#|   Scatterplot di consumo autostradale vs. cilindrata delle auto, dove i punti 
#|   sono più piccoli del grafico precedente e il testo e le etichette degli assi sono 
#|   più piccoli del testo circostante.
plot
```

```{r}
#| echo: false
#| fig-width: 8
#| out-width: "50%"
#| fig-alt: |
#|   Scatterplot di consumo autostradale vs. cilindrata delle auto, dove i punti 
#|   sono ancora più piccoli del grafico precedente e il testo e le etichette degli assi sono 
#|   ancora più piccoli del testo circostante.
plot
```

If you want to make sure the font size is consistent across all your figures, whenever you set `out-width`, you'll also need to adjust `fig-width` to maintain the same ratio with your default `out-width`.
For example, if your default `fig-width` is 6 and `out-width` is "70%", when you set `out-width: "50%"` you'll need to set `fig-width` to 4.3 (6 \* 0.5 / 0.7).

Figure sizing and scaling is an art and science and getting things right can require an iterative trial-and-error approach.
You can learn more about figure sizing in the [taking control of plot scaling blog post](https://www.tidyverse.org/blog/2020/08/taking-control-of-plot-scaling/).

### Other important options

When mingling code and text, like in this book, you can set `fig-show: hold` so that plots are shown after the code.
This has the pleasant side effect of forcing you to break up large blocks of code with their explanations.

To add a caption to the plot, use `fig-cap`.
In Quarto this will change the figure from inline to "floating".

If you're producing PDF output, the default graphics type is PDF.
This is a good default because PDFs are high quality vector graphics.
However, they can produce very large and slow plots if you are displaying thousands of points.
In that case, set `fig-format: "png"` to force the use of PNGs.
They are slightly lower quality, but will be much more compact.

It's a good idea to name code chunks that produce figures, even if you don't routinely label other chunks.
The chunk label is used to generate the file name of the graphic on disk, so naming your chunks makes it much easier to pick out plots and reuse in other circumstances (e.g., if you want to quickly drop a single plot into an email).

### Esercizi

1.  Open `diamond-sizes.qmd` in the visual editor, find an image of a diamond, copy it, and paste it into the document. Double click on the image and add a caption. Resize the image and render your document. Observe how the image is saved in your current working directory.
2.  Edit the label of the code chunk in `diamond-sizes.qmd` that generates a plot to start with the prefix `fig-` and add a caption to the figure with the chunk option `fig-cap`. Then, edit the text above the code chunk to add a cross-reference to the figure with Insert \> Cross Reference.
3.  Change the size of the figure with the following chunk options, one at a time, render your document, and describe how the figure changes.
    a.  `fig-width: 10`

    b.  `fig-height: 3`

    c.  `out-width: "100%"`

    d.  `out-width: "20%"`

## Tabelle

Simile alle figure, potete includere due tipi di tabelle in un documento Quarto.
Possono essere tabelle markdown che create direttamente nel vostro documento Quarto (usando il menu Insert Table) oppure possono essere tabelle generate come risultato di un chunk di codice.
In questa sezione ci concentreremo sui secondi, tabelle generate tramite calcolo.

Per default, Quarto stampa data frame e matrici come li vedreste nella console:

```{r}
mtcars[1:5, ]
```

Se preferite che i dati siano visualizzati con formattazione aggiuntiva potete usare la funzione `knitr::kable()`.
Il codice sotto genera @tbl-kable.

```{r}
#| label: tbl-kable
#| tbl-cap: Una kable knitr.
knitr::kable(mtcars[1:5, ], )
```

Leggete la documentazione per `?knitr::kable` per vedere gli altri modi in cui potete personalizzare la tabella.
Per personalizzazione ancora più profonda, considerate i pacchetti **gt**, **huxtable**, **reactable**, **kableExtra**, **xtable**, **stargazer**, **pander**, **tables** e **ascii**.
Ognuno fornisce un set di strumenti per restituire tabelle formattate dal codice R.

### Esercizi

1.  Aprite `diamond-sizes.qmd` nell'editor visuale, inserite un chunk di codice, e aggiungete una tabella con `knitr::kable()` che mostra le prime 5 righe del data frame `diamonds`.
2.  Visualizzate la stessa tabella con `gt::gt()` invece.
3.  Aggiungete un'etichetta di chunk che inizia con il prefisso `tbl-` e aggiungete una didascalia alla tabella con l'opzione chunk `tbl-cap`. Poi, modificate il testo sopra il chunk di codice per aggiungere un riferimento incrociato alla tabella con Insert \> Cross Reference.

## Caching {#sec-caching}

Normally, each render of a document starts from a completely clean slate.
This is great for reproducibility, because it ensures that you've captured every important computation in code.
However, it can be painful if you have some computations that take a long time.
The solution is `cache: true`.

You can enable the Knitr cache at the document level for caching the results of all computations in a document using standard YAML options:

``` yaml
---
title: "My Document"
execute: 
  cache: true
---
```

You can also enable caching at the chunk level for caching the results of computation in a specific chunk:

```{r}
#| echo: fenced
#| cache: true
# code for lengthy computation...
```

When set, this will save the output of the chunk to a specially named file on disk.
On subsequent runs, knitr will check to see if the code has changed, and if it hasn't, it will reuse the cached results.

The caching system must be used with care, because by default it is based on the code only, not its dependencies.
For example, here the `processed_data` chunk depends on the `raw-data` chunk:

````         
``` {{r}}
#| label: raw-data
#| cache: true
rawdata <- readr::read_csv("a_very_large_file.csv")
```
````

````         
``` {{r}}
#| label: processed_data
#| cache: true
processed_data <- rawdata |> 
  filter(!is.na(import_var)) |> 
  mutate(new_variable = complicated_transformation(x, y, z))
```
````

Caching the `processed_data` chunk means that it will get re-run if the dplyr pipeline is changed, but it won't get rerun if the `read_csv()` call changes.
You can avoid that problem with the `dependson` chunk option:

````         
``` {{r}}
#| label: processed-data
#| cache: true
#| dependson: "raw-data"
processed_data <- rawdata |> 
  filter(!is.na(import_var)) |> 
  mutate(new_variable = complicated_transformation(x, y, z))
```
````

`dependson` should contain a character vector of *every* chunk that the cached chunk depends on.
Knitr will update the results for the cached chunk whenever it detects that one of its dependencies have changed.

Note that the chunks won't update if `a_very_large_file.csv` changes, because knitr caching only tracks changes within the `.qmd` file.
If you want to also track changes to that file you can use the `cache.extra` option.
This is an arbitrary R expression that will invalidate the cache whenever it changes.
A good function to use is `file.mtime()`: it returns when it was last modified.
Then you can write:

````         
``` {{r}}
#| label: raw-data
#| cache: true
#| cache.extra: !expr file.mtime("a_very_large_file.csv")
rawdata <- readr::read_csv("a_very_large_file.csv")
```
````

We've followed the advice of [David Robinson](https://twitter.com/drob/status/738786604731490304) to name these chunks: each chunk is named after the primary object that it creates.
This makes it easier to understand the `dependson` specification.

As your caching strategies get progressively more complicated, it's a good idea to regularly clear out all your caches with `knitr::clean_cache()`.

### Esercizi

1.  Set up a network of chunks where `d` depends on `c` and `b`, and both `b` and `c` depend on `a`. Have each chunk print `lubridate::now()`, set `cache: true`, then verify your understanding of caching.

## Troubleshooting

Troubleshooting Quarto documents can be challenging because you are no longer in an interactive R environment, and you will need to learn some new tricks.
Additionally, the error could be due to issues with the Quarto document itself or due to the R code in the Quarto document.

One common error in documents with code chunks is duplicated chunk labels, which are especially pervasive if your workflow involves copying and pasting code chunks.
To address this issue, all you need to do is to change one of your duplicated labels.

If the errors are due to the R code in the document, the first thing you should always try is to recreate the problem in an interactive session.
Restart R, then "Run all chunks", either from the Code menu, under Run region or with the keyboard shortcut Ctrl + Alt + R.
If you're lucky, that will recreate the problem, and you can figure out what's going on interactively.

If that doesn't help, there must be something different between your interactive environment and the Quarto environment.
You're going to need to systematically explore the options.
The most common difference is the working directory: the working directory of a Quarto is the directory in which it lives.
Check the working directory is what you expect by including `getwd()` in a chunk.

Next, brainstorm all the things that might cause the bug.
You'll need to systematically check that they're the same in your R session and your Quarto session.
The easiest way to do that is to set `error: true` on the chunk causing the problem, then use `print()` and `str()` to check that settings are as you expect.

## YAML header

You can control many other "whole document" settings by tweaking the parameters of the YAML header.
You might wonder what YAML stands for: it's "YAML Ain't Markup Language", which is designed for representing hierarchical data in a way that's easy for humans to read and write.
Quarto uses it to control many details of the output.
Here we'll discuss three: self-contained documents, document parameters, and bibliographies.

### Self-contained

HTML documents typically have a number of external dependencies (e.g., images, CSS style sheets, JavaScript, etc.) and, by default, Quarto places these dependencies in a `_files` folder in the same directory as your `.qmd` file.
If you publish the HTML file on a hosting platform (e.g., QuartoPub, <https://quartopub.com/>), the dependencies in this directory are published with your document and hence are available in the published report.
However, if you want to email the report to a colleague, you might prefer to have a single, self-contained, HTML document that embeds all of its dependencies.
You can do this by specifying the `embed-resources` option:

``` yaml
format:
  html:
    embed-resources: true
```

The resulting file will be self-contained, such that it will need no external files and no internet access to be displayed properly by a browser.

### Parameters

Quarto documents can include one or more parameters whose values can be set when you render the report.
Parameters are useful when you want to re-render the same report with distinct values for various key inputs.
For example, you might be producing sales reports per branch, exam results by student, or demographic summaries by country.
To declare one or more parameters, use the `params` field.

This example uses a `my_class` parameter to determine which class of cars to display:

```{r}
#| echo: false
#| out-width: "100%"
#| comment: ""
cat(readr::read_file("quarto/fuel-economy.qmd"))
```

As you can see, parameters are available within the code chunks as a read-only list named `params`.

You can write atomic vectors directly into the YAML header.
You can also run arbitrary R expressions by prefacing the parameter value with `!expr`.
This is a good way to specify date/time parameters.

``` yaml
params:
  start: !expr lubridate::ymd("2015-01-01")
  snapshot: !expr lubridate::ymd_hms("2015-01-01 12:30:00")
```

### Bibliographies and Citations

Quarto can automatically generate citations and a bibliography in a number of styles.
The most straightforward way of adding citations and bibliographies to a Quarto document is using the visual editor in RStudio.

To add a citation using the visual editor, go to Insert \> Citation.
Citations can be inserted from a variety of sources:

1.  [DOI](https://quarto.org/docs/visual-editor/technical.html#citations-from-dois) (Document Object Identifier) references.

2.  [Zotero](https://quarto.org/docs/visual-editor/technical.html#citations-from-zotero) personal or group libraries.

3.  Searches of [Crossref](https://www.crossref.org/), [DataCite](https://datacite.org/), or [PubMed](https://pubmed.ncbi.nlm.nih.gov/).

4.  Your document bibliography (a `.bib` file in the directory of your document)

Under the hood, the visual mode uses the standard Pandoc markdown representation for citations (e.g., `[@citation]`).

If you add a citation using one of the first three methods, the visual editor will automatically create a `bibliography.bib` file for you and add the reference to it.
It will also add a `bibliography` field to the document YAML.
As you add more references, this file will get populated with their citations.
You can also directly edit this file using many common bibliography formats including BibLaTeX, BibTeX, EndNote, Medline.

To create a citation within your .qmd file in the source editor, use a key composed of '\@' + the citation identifier from the bibliography file.
Then place the citation in square brackets.
Here are some examples:

``` markdown
Separate multiple citations with a `;`: Blah blah [@smith04; @doe99].

You can add arbitrary comments inside the square brackets: 
Blah blah [see @doe99, pp. 33-35; also @smith04, ch. 1].

Remove the square brackets to create an in-text citation: @smith04 
says blah, or @smith04 [p. 33] says blah.

Add a `-` before the citation to suppress the author's name: 
Smith says blah [-@smith04].
```

When Quarto renders your file, it will build and append a bibliography to the end of your document.
The bibliography will contain each of the cited references from your bibliography file, but it will not contain a section heading.
As a result it is common practice to end your file with a section header for the bibliography, such as `# References` or `# Bibliography`.

You can change the style of your citations and bibliography by referencing a CSL (citation style language) file in the `csl` field:

``` yaml
bibliography: rmarkdown.bib
csl: apa.csl
```

As with the bibliography field, your csl file should contain a path to the file.
Here we assume that the csl file is in the same directory as the .qmd file.
A good place to find CSL style files for common bibliography styles is <https://github.com/citation-style-language/styles>.

## Workflow

Earlier, we discussed a basic workflow for capturing your R code where you work interactively in the *console*, then capture what works in the *script editor*.
Quarto brings together the console and the script editor, blurring the lines between interactive exploration and long-term code capture.
You can rapidly iterate within a chunk, editing and re-executing with Cmd/Ctrl + Shift + Enter.
When you're happy, you move on and start a new chunk.

Quarto is also important because it so tightly integrates prose and code.
This makes it a great **analysis notebook** because it lets you develop code and record your thoughts.
An analysis notebook shares many of the same goals as a classic lab notebook in the physical sciences.
It:

-   Records what you did and why you did it.
    Regardless of how great your memory is, if you don't record what you do, there will come a time when you have forgotten important details.
    Write them down so you don't forget!

-   Supports rigorous thinking.
    You are more likely to come up with a strong analysis if you record your thoughts as you go, and continue to reflect on them.
    This also saves you time when you eventually write up your analysis to share with others.

-   Helps others understand your work.
    It is rare to do data analysis by yourself, and you'll often be working as part of a team.
    A lab notebook helps you share not only what you've done, but why you did it with your colleagues or lab mates.

Much of the good advice about using lab notebooks effectively can also be translated to analysis notebooks.
We've drawn on our own experiences and Colin Purrington's advice on lab notebooks (<https://colinpurrington.com/tips/lab-notebooks>) to come up with the following tips:

-   Ensure each notebook has a descriptive title, an evocative file name, and a first paragraph that briefly describes the aims of the analysis.

-   Use the YAML header date field to record the date you started working on the notebook:

    ``` yaml
    date: 2016-08-23
    ```

    Use ISO8601 YYYY-MM-DD format so that's there no ambiguity.
    Use it even if you don't normally write dates that way!

-   If you spend a lot of time on an analysis idea and it turns out to be a dead end, don't delete it!
    Write up a brief note about why it failed and leave it in the notebook.
    That will help you avoid going down the same dead end when you come back to the analysis in the future.

-   Generally, you're better off doing data entry outside of R.
    But if you do need to record a small snippet of data, clearly lay it out using `tibble::tribble()`.

-   If you discover an error in a data file, never modify it directly, but instead write code to correct the value.
    Explain why you made the fix.

-   Before you finish for the day, make sure you can render the notebook.
    If you're using caching, make sure to clear the caches.
    That will let you fix any problems while the code is still fresh in your mind.

-   If you want your code to be reproducible in the long-run (i.e. so you can come back to run it next month or next year), you'll need to track the versions of the packages that your code uses.
    A rigorous approach is to use **renv**, <https://rstudio.github.io/renv/index.html>, which stores packages in your project directory.
    A quick and dirty hack is to include a chunk that runs `sessionInfo()` --- that won't let you easily recreate your packages as they are today, but at least you'll know what they were.

-   You are going to create many, many, many analysis notebooks over the course of your career.
    How are you going to organize them so you can find them again in the future?
    We recommend storing them in individual projects, and coming up with a good naming scheme.

## Riassunto

In questo capitolo vi abbiamo introdotto a Quarto per creare e pubblicare documenti computazionali riproducibili che includono il vostro codice e la vostra prosa in un posto.
Avete imparato a scrivere documenti Quarto in RStudio con l'editor visuale o sorgente, come funzionano i chunk di codice e come personalizzare le opzioni per essi, come includere figure e tabelle nei vostri documenti Quarto, e opzioni per il caching per i calcoli.
Inoltre, avete imparato ad aggiustare le opzioni header YAML per creare documenti autocontenuti o parametrizzati così come includere citazioni e bibliografia.
Vi abbiamo anche dato alcuni consigli per troubleshooting e workflow.

Mentre questa introduzione dovrebbe essere sufficiente per iniziare con Quarto, c'è ancora molto altro da imparare.
Quarto è ancora relativamente giovane, e sta ancora crescendo rapidamente.
Il posto migliore per rimanere aggiornati sulle innovazioni è il sito web ufficiale di Quarto: [https://quarto.org](https://quarto.org/){.uri}.

There are two important topics that we haven't covered here: collaboration and the details of accurately communicating your ideas to other humans.
Collaboration is a vital part of modern data science, and you can make your life much easier by using version control tools, like Git and GitHub.
We recommend "Happy Git with R", a user friendly introduction to Git and GitHub from R users, by Jenny Bryan.
The book is freely available online: <https://happygitwithr.com>.

We have also not touched on what you should actually write in order to clearly communicate the results of your analysis.
To improve your writing, we highly recommend reading either [*Style: Lessons in Clarity and Grace*](https://www.amazon.com/Style-Lessons-Clarity-Grace-12th/dp/0134080416) by Joseph M. Williams & Joseph Bizup, or [*The Sense of Structure: Writing from the Reader's Perspective*](https://www.amazon.com/Sense-Structure-Writing-Readers-Perspective/dp/0205296327) by George Gopen.
Both books will help you understand the structure of sentences and paragraphs, and give you the tools to make your writing more clear.
(These books are rather expensive if purchased new, but they're used by many English classes so there are plenty of cheap second-hand copies).
George Gopen also has a number of short articles on writing at <https://www.georgegopen.com/litigation-articles.html>.
They are aimed at lawyers, but almost everything applies to data scientists too.
